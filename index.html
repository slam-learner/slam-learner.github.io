<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"slam-learner.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":200},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="江苏大学 | 车辆工程 | SLAM">
<meta property="og:type" content="website">
<meta property="og:title" content="ydxの博客">
<meta property="og:url" content="https://slam-learner.github.io/index.html">
<meta property="og:site_name" content="ydxの博客">
<meta property="og:description" content="江苏大学 | 车辆工程 | SLAM">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ydx">
<meta property="article:tag" content="VSLAM IMU LIDAR GNSS INSS">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://slam-learner.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ydxの博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ydxの博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一个普普通通的帅比罢了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ydx"
      src="/images/avatar2.gif">
  <p class="site-author-name" itemprop="name">ydx</p>
  <div class="site-description" itemprop="description">江苏大学 | 车辆工程 | SLAM</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/slam-learner" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;slam-learner" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ydx199997@gmail.com" title="E-Mail → mailto:ydx199997@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2025/06/06/C++/Effective%20Series/Effective%20C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/06/C++/Effective%20Series/Effective%20C++/" class="post-title-link" itemprop="url">Effective C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-06 21:51:16" itemprop="dateCreated datePublished" datetime="2025-06-06T21:51:16+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>33k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="让自己熟悉-C"><a href="#让自己熟悉-C" class="headerlink" title="让自己熟悉 C++"></a>让自己熟悉 C++</h2><h3 id="条款-01-将-C-视作一个语言联邦"><a href="#条款-01-将-C-视作一个语言联邦" class="headerlink" title="条款 01 将 C++视作一个语言联邦"></a>条款 01 将 C++视作一个语言联邦</h3><p>C++是一个多重范式编程语言（multi-paradigm programming language）, 同时支持面向过程（procedural）、面向对象（OOP, object-oriented programming）、函数式（functional）、泛型编程（generic）、元编程（meta-programming）的语言。理解 C++，可以将 C++视作由相关语言的联邦而非单一语言。</p>
<ul>
<li>C：原始的 C 语言部分</li>
<li>OOP ：class （包含构造与析构）、封装（encapsulation）、继承（inheritance）、多态（polymorphism）、virtual 函数（动态绑定）</li>
<li>Template C++，即泛型编程（generic programming），也包含模板元编程（TMP，template meta-programming）</li>
<li>STL</li>
</ul>
<h3 id="条款-02-尽量以-const、enum、inline-替换-define"><a href="#条款-02-尽量以-const、enum、inline-替换-define" class="headerlink" title="条款 02 尽量以 const、enum、inline 替换 #define"></a>条款 02 尽量以 const、enum、inline 替换 <code>#define</code></h3><p>尽量少使用宏，尽可能用编译器替代预处理器</p>
<ul>
<li>对于常量，最好用 constexpr 对象或 enums 替换宏</li>
<li>对于 function-like macro，最好使用 inline 函数进行替换</li>
</ul>
<h3 id="条款-03-尽可能使用-const"><a href="#条款-03-尽可能使用-const" class="headerlink" title="条款 03 尽可能使用 const"></a>条款 03 尽可能使用 const</h3><h4 id="Const-指针"><a href="#Const-指针" class="headerlink" title="Const 指针"></a>Const 指针</h4><p>Const 在指针左侧——常量指针、底层 const<br>Const 在指针右侧——指针常量、顶层 const</p>
<h4 id="STL-迭代器"><a href="#STL-迭代器" class="headerlink" title="STL 迭代器"></a>STL 迭代器</h4><p>STL 如果使用到迭代器而又不通过迭代器修改元素的值，应尽可能使用 const_iterator</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>Const 与函数返回值结合，是限制返回值不会被修改，降低因使用错误而造成的错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有理数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>在这个代码示例中，对两个数值的乘积进行修改其实没有意义，那么为什么还要加上 const 限定返回值呢。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) </span><br></pre></td></tr></table></figure>
<p>假如比较操作时，遗漏掉一个等号，加上 const 限定的版本将会直接产生编译错误，反之则会正常编译通过，浪费在错误中进行排查的时间。另外 [[#条款 18 让接口容易被使用，不易被误用]] 中指出，一个良好的用户自定义类型应尽可能地与内置类型兼容，在上面的例子中，假如 a 和 b 是基础类型（fundamental type），比如 int 类型，上面这个语句本身就无法编译通过，因为 a  * b 的结果是一个右值，它无法被赋值，那么自定义类型也应该与这种行为保持一致。</p>
<p>在函数声明的最后加上 const，则说明这个函数是一个类成员函数，它限制此函数不对成员变量进行修改。</p>
<p>Note:<br>对于按值返回的用户自定义类型（如 <code>Rational</code>），是否加 <code>const</code> 是有争议的：</p>
<ul>
<li><strong>优点：</strong> 防止错误赋值</li>
<li><strong>缺点：</strong> 阻止移动语义（尤其是在 C++11 后）</li>
</ul>
<p>现代 C++ 的实践建议是：</p>
<blockquote>
<p>不要为按值返回的类型加 <code>const</code>，除非你明确希望禁止赋值。</p>
</blockquote>
<p>Note:<br>两个成员函数如果常量性不同，将被视作是两个不同的重载</p>
<h4 id="实践技巧：复用-const-non-const-成员函数逻辑"><a href="#实践技巧：复用-const-non-const-成员函数逻辑" class="headerlink" title="实践技巧：复用 const/non-const 成员函数逻辑"></a>实践技巧：复用 const/non-const 成员函数逻辑</h4><p>当 <code>const</code> 和 <code>non-const</code> 成员函数有着实质等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">checkBounds</span>(pos);</span><br><span class="line">    <span class="keyword">return</span> pText[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos) &#123;</span><br><span class="line">    <span class="built_in">checkBounds</span>(pos);</span><br><span class="line">    <span class="keyword">return</span> pText[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string pText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">checkBounds</span>(pos);</span><br><span class="line">    <span class="keyword">return</span> pText[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CTextBlock&amp;&gt;(*<span class="keyword">this</span>)[pos]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string pText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条款-04-确保对象在使用前已被初始化"><a href="#条款-04-确保对象在使用前已被初始化" class="headerlink" title="条款 04 确保对象在使用前已被初始化"></a>条款 04 确保对象在使用前已被初始化</h3><ul>
<li>为内置型对象进行手工初始化，因为 C++不保证初始化他们</li>
<li>对象的成员变量初始化动作发生在进入构造函数本体之前，构造函数内的动作更准确的应该叫做赋值动作。不要将赋值和初始化混淆，赋值的方式也能够保证对象带有预期的值，但是效率较低，对象会先被默认构造，然后再调用赋值运算符。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>行为</th>
<th>发生时机</th>
<th>表达式</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化（Initialization）</td>
<td>对象创建时</td>
<td>构造函数初始化列表</td>
<td>直接构造成员变量</td>
<td></td>
</tr>
<tr>
<td>赋值（Assignment）</td>
<td>对象已存在后</td>
<td>等号赋值语句</td>
<td>调用成员类型的赋值运算符</td>
</tr>
</tbody>
</table>
</div>
<p>赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">            <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones) &#123;</span><br><span class="line">    theName = name;</span><br><span class="line">    theAddress = address;</span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),</span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)  <span class="comment">// 内置类型也最好初始化</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果一个类有多个构造函数，它们可能都需要初始化同一组成员。为了避免重复写初始化列表，可以将“公共初始化逻辑”提取到一个私有函数中，适用于那些赋值和初始化成本相同的成员（如 <code>int</code>、<code>double</code> 等）。改用它们的赋值操作，并将那些赋值操作移往某个函数（通常是 private) ，供所有构造函数调用。这种做法在“成员变量的初值系由文件或数据库读入”时特别有用。然而，比起经由赋值操作完成的“伪初始化 ”(pseudo-initialization) ，通过成员初值列 (member initialization list) 完成的“真正初始化”通常更加可取。</p>
</li>
<li><p>无需记住哪些成员必须用初始化列表，只要所有成员都写在初始化列表中，永远不会错。成员变量总是以它们在类中声明的顺序进行初始化，与成员初始化列表中出现的顺序无关，因此应始终按照声明顺序写初始化列表。</p>
</li>
<li><p>最后一点：注意不同编译单元中的 non-local static 对象的初始化顺序。函数内的 static 对象被称为 local static 对象，其它 static 对象被称为 non-local static 对象，C++对于“定义于不同编译单元内的 non-local static 对象”的初始化顺序是未定义的，因此常用手法是利用 Singleton 模式将 non-local static 对象替换为 local static 对象（C++11 之后保证线程安全），这个手法的基础在于：C++保证，函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化。</p>
</li>
</ul>
<p>Note:</p>
<blockquote>
<p>Static 对象的生命周期从其被构造出来开始直到程序结束为止，他们的析构函数会在 main ()函数结束之后被自动调用。<br>所谓编译单元 (translation unit) 是指产出单一目标文件 (single object file) 的那些源码，每个编译单元由单一源码文件加上其所含入的头文件 ( #include files) 组成。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式或 global-like 使用方式推荐如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> FileSystem&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> FileSystem fs; <span class="comment">// ✅ 函数内 static，初始化顺序受保障</span></span><br><span class="line">        <span class="keyword">return</span> fs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款-05-了解-C-默认生成了哪些函数"><a href="#条款-05-了解-C-默认生成了哪些函数" class="headerlink" title="条款 05 了解 C++默认生成了哪些函数"></a>条款 05 了解 C++默认生成了哪些函数</h3><ul>
<li>编译器会为 class 生成 default constructor、copy constructor、copy assignment operator、destructor，所有这些函数都是 public 且 inline 的。编译器会尝试隐式声明这些函数，但是否定义（生成代码）要看是否真正被使用（即所谓“隐式声明、按需定义”）。</li>
</ul>
<p>Note:  </p>
<blockquote>
<p>空类对象并非真的空，它会拥有上述编译器生成的成员函数。并且空类的对象通常至少占用一个字节，以便它们在内存中拥有唯一地址。</p>
</blockquote>
<ul>
<li>Default 构造函数和析构函数会调用 base class 和 non-static 成员变量的构造函数和析构函数</li>
<li>对于拷贝构造函数，如果类内由深拷贝的需求，或者类内有引用成员或者 const 成员，应当自定义拷贝行为</li>
<li>编译器生成的析构函数是 non-virtual 的，除非这个 class 的 base class 自身声明有 virtual 析构函数</li>
</ul>
<p>Note:<br>C++11 之后，除了以上四个函数外，编译器还会自动生成移动构造函数和移动赋值函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>默认生成条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>默认构造函数</strong> <code>T()</code></td>
<td>没有定义任何构造函数时自动生成</td>
<td>用于默认初始化</td>
</tr>
<tr>
<td><strong>析构函数</strong> <code>~T()</code></td>
<td>未定义析构函数时自动生成</td>
<td>用于清理资源</td>
</tr>
<tr>
<td><strong>拷贝构造函数</strong> <code>T(const T&amp;)</code></td>
<td>未定义任何拷贝/移动构造时自动生成</td>
<td>用于按值传递、拷贝对象</td>
</tr>
<tr>
<td><strong>拷贝赋值运算符</strong> <code>T&amp; operator=(const T&amp;)</code></td>
<td>未定义任何赋值/移动赋值时自动生成</td>
<td>用于对象赋值</td>
</tr>
<tr>
<td><strong>移动构造函数</strong> <code>T(T&amp;&amp;)</code></td>
<td>若未定义拷贝/移动构造、析构等，编译器尝试生成</td>
<td>用于右值引用转移资源</td>
</tr>
<tr>
<td><strong>移动赋值运算符</strong> <code>T&amp; operator=(T&amp;&amp;)</code></td>
<td>条件如上</td>
<td>同样是右值资源转移</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>默认构造</th>
<th>拷贝构造</th>
<th>拷贝赋值</th>
<th>移动构造</th>
<th>移动赋值</th>
<th>析构</th>
</tr>
</thead>
<tbody>
<tr>
<td>什么都不写</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅（C++11 起）</td>
<td>✅（C++11 起）</td>
<td>✅</td>
</tr>
<tr>
<td>显式定义了析构函数</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>显式定义了拷贝构造或赋值</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>显式定义了移动构造或赋值</td>
<td>✅</td>
<td>❌（需手写）</td>
<td>❌（需手写）</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>显式定义了构造函数（带参）</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
</div>
<p>现代 C++推荐使用规则：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>使用目的</th>
<th>推荐写法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>明确需要默认行为</td>
<td><code>ClassName() = default;</code> 等</td>
<td>不再依赖隐式生成，更直观</td>
</tr>
<tr>
<td>禁止某个行为</td>
<td><code>ClassName(const ClassName&amp;) = delete;</code></td>
<td>防止拷贝或赋值错误使用</td>
</tr>
<tr>
<td>自己管理资源（RAII）</td>
<td>显式写析构/拷贝/移动函数</td>
<td>比如用到 <code>new[]</code>、文件句柄等</td>
</tr>
<tr>
<td>继承自非平凡基类</td>
<td>明确 default / delete 是必要的</td>
<td>避免切片或行为不一致</td>
</tr>
<tr>
<td>避免浅拷贝问题</td>
<td>显式禁用拷贝，只支持移动</td>
<td>典型于 <code>std::unique_ptr</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="条款-06-若不想使用编译器自动生成的函数，应当明确拒绝"><a href="#条款-06-若不想使用编译器自动生成的函数，应当明确拒绝" class="headerlink" title="条款 06 若不想使用编译器自动生成的函数，应当明确拒绝"></a>条款 06 若不想使用编译器自动生成的函数，应当明确拒绝</h3><ul>
<li>C++11 中，可以使用 <code>delete</code> 关键字显式禁用某个函数</li>
<li>C++98 中，可以将某个函数声明为 private 且不实现</li>
</ul>
<h3 id="条款-07-为多态基类声明-virtual-析构函数"><a href="#条款-07-为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07 为多态基类声明 virtual 析构函数"></a>条款 07 为多态基类声明 virtual 析构函数</h3><ul>
<li>带多态性质的 base class 应该声明 virtual 析构函数，以确保其 derived class 的析构函数被调用。防止指向派生类的基类指针在被释放时只局部销毁了该对象，造成内存泄漏</li>
<li>如果一个 class 带有任何 virtual 函数，那么它应该有 virtual 析构函数</li>
<li>普通的类无需也不应该有虚析构函数，虚函数是有代价的</li>
<li>如果一个类没有被设计为基类，又有被错继承的风险，应将类声明为 <code>final</code>（C++11）。</li>
</ul>
<h3 id="条款-08-不要让异常逃离析构函数"><a href="#条款-08-不要让异常逃离析构函数" class="headerlink" title="条款 08 不要让异常逃离析构函数"></a>条款 08 不要让异常逃离析构函数</h3><ul>
<li>析构函数不应该抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应捕捉任何异常，然后吞掉异常或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
<h3 id="条款-09-构造-析构函数内不要调用虚函数"><a href="#条款-09-构造-析构函数内不要调用虚函数" class="headerlink" title="条款 09 构造/析构函数内不要调用虚函数"></a>条款 09 构造/析构函数内不要调用虚函数</h3><ul>
<li><p><strong>构造/析构期间即使调用虚函数也不会表现出多态行为。</strong> C++中构造函数的调用顺序为：基类➡派生类，在构造基类期间，派生类还没有被构造完成，所以虚表指针（vptr）仍指向基类的虚表，虚函数调用会调用到基类函数，而非派生类的。因此在基类构造期间，虚函数非虚。类对象的基类构造期间，对象的类型为基类而不是派生类，运行期类型信息也会把对象视作基类。相同道理也适用于析构函数，一旦派生类开始析构，对象内专属于派生类的成员变量就会编程未定义值，C++将它们视作不存在，进入基类的析构函数后，对象就被视作基类对象。</p>
</li>
<li><p>解决办法之一是，既然你无法使用 virtual 函数从 base class 向下调用，那就在构造期间令 derived class 将必要的构造信息向上传递至 base class 构造函数</p>
</li>
</ul>
<h3 id="条款-10-赋值运算符应返回指向自身的引用"><a href="#条款-10-赋值运算符应返回指向自身的引用" class="headerlink" title="条款 10 赋值运算符应返回指向自身的引用"></a>条款 10 赋值运算符应返回指向自身的引用</h3><ul>
<li>赋值操作符应该返回一个指向自身的引用，以便于链式赋值<br>这个协议不仅适用于标准赋值形式，也适用于所有<strong>赋值</strong>相关运算，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)  <span class="comment">// 这个协议适用于</span></span><br><span class="line">    &#123;                                      <span class="comment">// +=、-+、*=等等。</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>；                     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs)             <span class="comment">// 此函数也适用，即使</span></span><br><span class="line">    &#123;                                      <span class="comment">// 此一操作符的参数类型</span></span><br><span class="line">        ...                                <span class="comment">// 不符协定。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>；                   </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 bool 操作符重载的返回值有所不同，请留心，以免无限调用自身。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  <span class="comment">// 定义操作符的重载,如果！=，这里做相应修改即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;  <span class="comment">// 不能return *this 否则无限调用自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>！=(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span>  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ！(*<span class="keyword">this</span> == other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在设计接口时一个重要的原则是，让自己的接口和内置类型相同功能的接口尽可能相似，所以如果没有特殊情况，赋值运算符就应当返回自身的引用。</p>
<h3 id="条款-11-赋值运算符中应避免自我赋值"><a href="#条款-11-赋值运算符中应避免自我赋值" class="headerlink" title="条款 11 赋值运算符中应避免自我赋值"></a>条款 11 赋值运算符中应避免自我赋值</h3><p>避免自我赋值的常用技术包括以下几种：</p>
<ul>
<li>比较“来源对象”和“目标对象”的地址，如果相同则直接返回</li>
<li>精心周到的语句顺序，例如先“记住”原有对象，然后“复制”新值，最后“销毁”原有对象</li>
<li>利用 copy-and-swap 技术</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</li>
</ul>
<h3 id="条款-12-复制对象时不要遗漏任何成员"><a href="#条款-12-复制对象时不要遗漏任何成员" class="headerlink" title="条款 12 复制对象时不要遗漏任何成员"></a>条款 12 复制对象时不要遗漏任何成员</h3><ul>
<li>类添加成员变量时，不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果忘记处理，编译器不会给出警告或者报错。</li>
<li>如果类有继承行为，那么在为派生类编写拷贝构造函数是要注意复制基类的每一个成员，这些成员往往是私有的，所以无法直接访问，应当让派生类的拷贝构造调用基类的拷贝构造函数来实现成员的复制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在成员初始化列表显式调用基类的拷贝构造函数</span></span><br><span class="line">ChildClass::<span class="built_in">ChildClass</span>(<span class="type">const</span> ChildClass&amp; rhs) : <span class="built_in">BaseClass</span>(rhs) &#123;  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个，这虽然看上去是一个避免代码重复的好方法，但是是荒谬的。原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。如果想要避免重复代码，可以将重复部分提成一个私有函数，两个函数共同进行调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="built_in">copy_from</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">            <span class="built_in">copy_from</span>(rhs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> MyClass&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝所有成员</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = rhs.a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = rhs.b;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款-13-使用对象管理资源（RAII）"><a href="#条款-13-使用对象管理资源（RAII）" class="headerlink" title="条款 13 使用对象管理资源（RAII）"></a>条款 13 使用对象管理资源（RAII）</h3><ul>
<li>为防止资源泄漏，请使用 RAII 对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>C++11 之后常使用 unique_ptr 或 shared_ptr 作为资源管理类。<br>本条款的核心观点在于：以面向流程的方式管理资源的获取和释），总是会在各种意外出现时，丢失对资源的控制权并造成资源泄露。以面向过程的方式管理资源意味着，资源的获取和释放都分别被封装在函数中。这种管理方式意味着资源的索取者肩负着释放它的责任，但此时我们就要考虑一下以下几个问题：调用者是否总是会记得释放呢？调用者是否有能力保证合理地释放资源呢？不给调用者过多义务的设计才是一个良好的设计。</li>
</ul>
<p>首先我们看一下哪些问题会让调用者释放资源失败：</p>
<ul>
<li>一句简单的 <code>delete</code> 语句并不会一定执行，例如一个过早的 <code>return</code> 语句或是在 <code>delete</code> 语句之前某个语句抛出了异常。</li>
<li>谨慎的编码可能能在这一时刻保证程序不犯错误，但无法保证软件接受维护时，其他人在 delete 语句之前加入的 return 语句或异常重复第一条错误。</li>
</ul>
<p>为了保证资源的获取和释放一定会合理执行，我们把获取资源和释放资源的任务封装在一个对象中。当我们构造这个对象时资源自动获取，当我们不需要资源时，我们让对象析构。这便是“Resource Acquisition Is Initialization; RAII”的想法，因为我们总是在获得一笔资源后于同一语句内初始化某个管理对象。无论控制流如何离开区块，一旦对象被销毁（比如离开对象的作用域）其析构函数会自动被调用。</p>
<h3 id="条款-14-资源管理类要小心复制行为"><a href="#条款-14-资源管理类要小心复制行为" class="headerlink" title="条款 14 资源管理类要小心复制行为"></a>条款 14 资源管理类要小心复制行为</h3><ul>
<li>复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为。  </li>
<li>如果对想要自行管理 delete（或其他类似行为如上锁/解锁）的类处理复制问题，有以下方案，先创建自己的资源管理类，然后可选择：</li>
</ul>
<blockquote>
<ol>
<li>禁止复制，使用 [[#条款 06 若不想使用编译器自动生成的函数，应当明确拒绝]] 的方法  </li>
<li>对复制的资源做引用计数（如 shared_ptr），shared_ptr 支持初始化时自定义删除函数</li>
<li>做真正的深复制  </li>
<li>转移资源的拥有权，如 unique_ptr，只保持新对象拥有。</li>
</ol>
</blockquote>
<h3 id="条款-15-资源管理类应提供对所管理的原始对象的访问接口"><a href="#条款-15-资源管理类应提供对所管理的原始对象的访问接口" class="headerlink" title="条款 15 资源管理类应提供对所管理的原始对象的访问接口"></a>条款 15 资源管理类应提供对所管理的原始对象的访问接口</h3><ol>
<li>许多 API 需要直接引用资源，而不是通过资源管理类。虽然它们不合规范，但很难避免使用它们。所以资源管理类应该提供访问原始资源的能力。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li>
</ol>
<h3 id="条款-16-成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16-成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16 成对使用 new 和 delete 时要采用相同形式"></a>条款 16 成对使用 new 和 delete 时要采用相同形式</h3><ul>
<li>通过 new 生成对象时，有两件事发生：</li>
</ul>
<blockquote>
<p>第一，内存被分配出来（通过名为 operator new 的函数，见 [[#条款 49 了解 new-handler 的行为]] 和 [[#条款 51 编写 new 和 delete 需要固守常规]]）。<br>第二，针对此内存会有一个（或更多）构造函数被调用。</p>
</blockquote>
<ul>
<li>当使用 delete 时，也有两件事发生：针对此内存会有一个（或更多）析构函数被调用，然后内存才被释放（通过名为 operator delete 的函数，见 [[#条款 51 编写 new 和 delete 需要固守常规]]）。</li>
<li>如果调用 new 时使用[]，必须在对应调用 delete 时也使用[]。如果调用 new 时没有使用[]，那么也不该在调用 delete 时使用[]。</li>
<li>对于数组，不建议使用 typedef 行为，这会让使用者不记得去 delete []。对于这种情况，建议使用 string 或者 vector。</li>
</ul>
<h3 id="条款-17-以独立语句将-new-对象放入智能指针"><a href="#条款-17-以独立语句将-new-对象放入智能指针" class="headerlink" title="条款 17 以独立语句将 new 对象放入智能指针"></a>条款 17 以独立语句将 new 对象放入智能指针</h3><ol>
<li>以独立语句将 new 的对象存储于智能指针中，这样能够保证动态获取的资源一定能被资源管理对象接管，不会造成内存泄漏。</li>
<li>如果不这样做，一旦在【资源申请成功】和【资源管理对象接管资源】之间抛出了异常，就有可能产生难以察觉的资源泄漏。因为异常本身就是意料之外的错误，不容易复现，从而导致资源泄漏无法轻易定位。</li>
</ol>
<p>说明：<br>假设有两个函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果按照如下方法调用 <code>processWidget</code> 函数，则有可能造成资源泄漏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> <span class="built_in">Widget</span>()), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>这是因为编译器在编译 <code>processWidget</code> 函数之前会检查即将被传递的各个实参，第二个实参是对 <code>priority</code> 函数的简单调用，而第一个实参包含两个部分：</p>
<ul>
<li>执行 <code>new Widget()</code> 表达式动态创建 <code>Widget</code> 对象。</li>
<li>调用 <code>std::shared_ptr</code> 类的构造函数并使用 <code>Widget</code> 对象的指针作为构造参数。</li>
</ul>
<p>所以，在调用 <code>processWidget</code> 函数之前编译器会做以下三件事情：</p>
<ul>
<li>执行 <code>new Widget()</code> 表达式动态创建 <code>Widget</code> 对象</li>
<li>调用 <code>std::shared_ptr</code> 类的构造函数并使用 <code>Widget</code> 对象的指针作为构造参数</li>
<li>调用 <code>priority</code> 函数得到优先级</li>
</ul>
<p>以何种顺序执行以上三个步骤，C++语句并没有给出严格规定，具体由编译器来决定。</p>
<p>能够明确知道的是执行 <code>new Widget</code> 表达式肯定是在调用 <code>shared_ptr</code> 构造函数之前，但调用 <code>priority</code> 函数则有可能是在第 1、2、3 中任意一步执行。假设调用 <code>priority</code> 函数在第 2 步执行，将获得以下执行顺序：</p>
<ol>
<li>执行 <code>new Widget()</code> 表达式动态创建 <code>Widget</code> 对象</li>
<li>调用 <code>priority</code> 函数得到优先级</li>
<li>调用 <code>std::shared_ptr</code> 类的构造函数并使用 <code>Widget</code> 对象的指针作为构造参数</li>
</ol>
<p>如果在调用 <code>priority</code> 函数的过程中发生了异常，那么 <code>new Widget()</code> 表达式返回的指针会被遗失，就有可能造成资源泄漏。原因是在【资源被创建】和【资源被管理对象接管】之间造成了异常干扰。</p>
<p><strong>解决办法：</strong></p>
<p>分离构造 <code>Widget</code> 对象的语句，在单独的语句中执行 <code>new Widget()</code> 表达式并调用 <code>shared_ptr</code> 类的构造函数，最后将智能指针传给 <code>processWidget</code> 函数。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget())</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>编译器对于<strong>跨越语句的各项操作</strong>没有重新排列的自由，只有在语句内才拥有某种自由度。</p>
<p>因此在上述代码中【（1）执行 <code>new Widget()</code> 表达式和（2）调用 <code>shared_ptr</code> 类的构造函数】与【对 <code>priority</code> 函数的调用】是在不同的语句中，被分隔开来了，所以编译器不得在它们之间任意选择执行次序。</p>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款-18-让接口容易被使用，不易被误用"><a href="#条款-18-让接口容易被使用，不易被误用" class="headerlink" title="条款 18 让接口容易被使用，不易被误用"></a>条款 18 让接口容易被使用，不易被误用</h3><p>在设计接口时，我们常常会错误地假设，接口的调用者拥有某些必要的知识来规避一些常识性的错误。但事实上，接口的调用者并不总是像正在设计接口的我们一样了解接口内部细节。接口的调用者可能是别人，也可能是未来的自己。所以一个合理的接口，应该尽可能的从语法层面并在编译之时运行之前，帮助接口的调用者规避可能的风险。</p>
<p>如下，设计一个日期类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> <span class="type">int</span> month, <span class="type">const</span> <span class="type">int</span> day, <span class="type">int</span> <span class="type">const</span> year) </span><br><span class="line">        : <span class="built_in">m_month</span>(month), <span class="built_in">m_day</span>(day), <span class="built_in">m_year</span>(year) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_day;</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">    <span class="type">int</span> m_year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>错误调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">29</span>, <span class="number">5</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">// 调用顺序错乱，应该是 5, 29, 2014</span></span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">// 传入参数有误，2月没有30号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用外覆类型（wrapper）提醒调用者传参错误检查，将参数的附加条件限制在类型本身</li>
</ul>
<p>当调用者试图传入数字“13”来表达一个“月份”的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁——调用者只有在尝试过后才发现自己手残把“12”写成了“13”。如果在设计参数类型时就把“月份”这一类型抽象出来，比如使用 enum class（强枚举类型），就能帮助客户在编译时期就发现问题，把参数的附加条件限制在类型本身，可以让接口更易用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> day)</span> : m_day (day) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">const</span> <span class="type">int</span> month)</span> : m_month(month) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_month;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">const</span> <span class="type">int</span> year)</span> : m_year(year) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month &amp;month, <span class="type">const</span> Day &amp;day,  <span class="type">const</span> Year &amp;year) </span><br><span class="line">        : <span class="built_in">m_month</span>(month), <span class="built_in">m_day</span>(day), <span class="built_in">m_year</span>(year) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Day m_day;</span><br><span class="line">    Month m_month;</span><br><span class="line">    Year m_year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类型错误得到预防，但值还是没有得到保障</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">2014</span>)</span></span>;  <span class="comment">// error,类型错误</span></span><br><span class="line"><span class="function">Date <span class="title">d3</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">2</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">// error,类型错误</span></span><br><span class="line"><span class="function">Date <span class="title">d4</span><span class="params">(Month(<span class="number">2</span>), Day(<span class="number">30</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>可通过设计对应的类型的值限制来达到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E_MON</span>&#123;JAN = <span class="number">1</span>, FEC, MAR, APR, MAY, JUN, JUL, AGU, SEP, OCT, NOV, DEC&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">const</span> E_MON month)</span> : m_month(month) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d4</span><span class="params">(Month(Month::E_MON::DEC), Day(<span class="number">30</span>), Year(<span class="number">2014</span>))</span></span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从语法层面限制调用者不能做的事</li>
</ul>
<p>接口的调用者往往无意甚至没有意识到自己犯了个错误，所以接口的设计者必须在语法层面做出限制。一个比较常见的限制是加上 <code>const</code>，比如在 <code>operate*</code> 的返回类型上加上 <code>const</code> 修饰，可以防止无意错误的赋值 <code>if (a * b = c)</code>。</p>
<ul>
<li>接口应表现出与内置类型的一致性</li>
</ul>
<p>让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和 STL 应具备一致性，可以有效防止调用者犯错误。或者你有两个对象相乘的需求，那么你最好重载 <code>operator*</code> 而并非设计名为 <code>multiply</code> 的成员函数。</p>
<ul>
<li>从语法层面限制调用者<strong>必须做的事</strong></li>
</ul>
<p><strong>别让接口的调用者总是记得做某些事情</strong>，接口的设计者应在假定他们<strong>总是忘记</strong>这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成纯虚函数并要求调用者继承该抽象类，强制他们去实现。在核心方法前后对设置和恢复环境的调用，则应由接口设计者操心。</p>
<p>当方法的调用者（我们的客户）责任越少，他们可能犯的错误也就越少。</p>
<p>请记住：</p>
<p>①好的接口易于正确使用，而难以错误使用。你应该在你的所有接口中为这个特性努力。 ②使易于正确使用的方法包括在接口和行为兼容性上与内建类型保持一致。 ③预防错误的方法包括创建新的类型，限定类型的操作，约束对象的值，以及消除客户的资源管理职责。 ④ <code>std::shared_ptr</code> 支持自定义 deleter。这可以防止 cross-DLL 问题，能用于自动解锁互斥体（参见 [[#条款 14 资源管理类要小心复制行为]]）</p>
<h3 id="条款-19-设计-class-如同设计一个类型"><a href="#条款-19-设计-class-如同设计一个类型" class="headerlink" title="条款 19 设计 class 如同设计一个类型"></a>条款 19 设计 class 如同设计一个类型</h3><ul>
<li>对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求</li>
<li>对象的构造函数与赋值行为应有何区别：构造函数和赋值操作符的区别，重点在资源管理上（[[#条款 04 确保对象在使用前已被初始化]]）</li>
<li>对象被拷贝时应考虑的行为：拷贝构造函数</li>
<li>对象的合法值是什么？最好在语法层面、至少在编译前应对用户做出监督</li>
<li>新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题</li>
<li>新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非 explicit 函数之间的取舍</li>
<li>新类型是否需要重载操作符</li>
<li>什么样的接口应当暴露在外，而什么样的技术应当封装在内（public 和 private）</li>
<li>新类型的效率、资源获取归还、线程安全性和异常安全性如何保证</li>
<li>这个类是否具备 template 的潜质，如果有的话，就应改为模板类</li>
</ul>
<h3 id="条款-20-优先使用-pass-by-reference-to-const-而不是值传递"><a href="#条款-20-优先使用-pass-by-reference-to-const-而不是值传递" class="headerlink" title="条款 20 优先使用 pass-by-reference-to-const 而不是值传递"></a>条款 20 优先使用 pass-by-reference-to-const 而不是值传递</h3><p>函数接口应该以 <code>const</code> 引用的形式传参，而不应该按值传参，否则可能会有以下问题：</p>
<ul>
<li>按值传参涉及大量参数的复制，这些副本大多是没有必要的。</li>
<li>如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。</li>
<li>对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。（对象切割）</li>
<li>小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>尽量以 pass-by-reference-to-const 替换 pass-by-value</strong>。前者通常比较高效，并可避免切割问题（slicing problem）。</li>
<li>以上规则<strong>并不适用于内置类型，以及 STL 的选代器和函数对象</strong>。对它们而言，pass-by-value 往往比较适当。</li>
</ul>
<h3 id="条款-21-必须返回对象时，别妄想返回其-reference"><a href="#条款-21-必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21 必须返回对象时，别妄想返回其 reference"></a>条款 21 必须返回对象时，别妄想返回其 reference</h3><p>在一些函数内部，如果返回局部对象的引用会造成悬垂引用问题，从而导致未定义行为。在 C++11 之前，以值方式返回对象可能会引发拷贝，但是这个开销是不可避免的。C++11 之后，更推荐以值的方式返回，其优点如下：</p>
<ul>
<li><strong>返回值优化（RVO）</strong>：编译器通常会优化掉返回值的拷贝或移动，性能开销很低。</li>
<li><strong>安全性好</strong>：返回值不会涉及悬垂引用的问题。</li>
<li><strong>代码清晰</strong>：返回值表达的是“函数返回的只是一个副本”，更易于理解和维护。</li>
</ul>
<p>C++17 之前, RVO 并不是强制的，不过即使没有 RVO，也可以使用 C++11 引入的移动语义节省掉拷贝的开支，而 C++17 之后，RVO 被强制保证，所以以值的形式返回完全不会涉及到拷贝或移动操作，假设某个函数的返回类型的拷贝构造函数和移动构造函数都被删除掉，它被以值的形式返回，由于 RVO 的强制保证，定义某个变量接受这个返回值并不会引发错误，因为这里并不牵涉到拷贝或者移动构造，它相当于是在调用点进行直接构造（direct-initialization）的。</p>
<blockquote>
<p>C++17 中的 <strong>mandatory copy elision</strong>（强制拷贝省略）<br>拷贝省略是一种编译器优化技术，它允许编译器<strong>省略掉某些对象的拷贝或移动操作</strong>，尤其是在函数返回对象或构造临时对象的过程中。<br>在 C++11/14 中，这是一种“<strong>允许的优化</strong>”；<br>但在 C++17 中，在某些特定情形下，它变成了“<strong>语义强制要求</strong>”：</p>
</blockquote>
<h4 id="C-17-拷贝省略的情形"><a href="#C-17-拷贝省略的情形" class="headerlink" title="C++17 拷贝省略的情形"></a>C++17 拷贝省略的情形</h4><p> <strong>情形 1：返回局部对象（Named Return Value）</strong><br>在此情形下，编译器会执行具名返回值优化（NRVO，Named Return value Optimization），但此优化并没有收到标准的强制要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    Return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>t</code> 是一个<strong>局部变量</strong>；</li>
<li>返回语句直接返回 <code>t</code>，<strong>类型完全匹配</strong>；</li>
<li>没有类型转换或包装；</li>
</ul>
<p><strong>情形 2：返回临时对象（Temporary Return Value）</strong><br>在此情形下，C++17 标准强制要求进行返回值优化（RVO）完成拷贝省略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T</span>(); <span class="comment">// 直接返回一个临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这叫做 <strong>临时值返回（temporary expression return）</strong>。</p>
<ul>
<li>这里 <code>T()</code> 是一个临时对象；</li>
<li>返回语句中没有中间变量或转换；</li>
<li>类型完全匹配；</li>
<li>所以编译器必须执行 <strong>copy elision</strong>，不会调用拷贝或移动构造函数。</li>
</ul>
<h4 id="强制-RVO-的前提条件"><a href="#强制-RVO-的前提条件" class="headerlink" title="强制 RVO 的前提条件"></a>强制 RVO 的前提条件</h4><p>C++17 中强制 copy elision <strong>只适用于这两种情形</strong>，前提是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件</th>
<th>要求</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型</td>
<td>和函数的返回类型完全一致</td>
<td></td>
</tr>
<tr>
<td>不发生类型转换</td>
<td>没有转换为基类、父类型等</td>
<td></td>
</tr>
<tr>
<td>返回的是临时对象</td>
<td>且是直接 <code>return</code> 的</td>
</tr>
</tbody>
</table>
</div>
<h4 id="优化失效的情况"><a href="#优化失效的情况" class="headerlink" title="优化失效的情况"></a>优化失效的情况</h4><p>情形 1：返回引用或通过类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> d; <span class="comment">// ❌ 发生类型转换（Derived → Base），不是强制 RVO 情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回类型需要进行类型转换，所以不会得到 RVO 保证。</p>
<p>情形 2：<code>return std::move(t)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(t); <span class="comment">// ❌ 不强制 RVO，调用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::move(t)</code> 会将 <code>t</code> 变为右值；</li>
<li>这里会尝试调用 <strong>T 的移动构造函数</strong>；</li>
<li>所以这个不是 C++17 强制省略的情形（但编译器仍可能优化它，属于“非强制” copy elision）。</li>
</ul>
<p>情形 3 运行时依赖（在不同的条件分支下返回不同变量）</p>
<p>当编译器无法单纯通过函数来决定返回哪个对象实例时，会禁用（N）RVO。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  Obj o1;</span><br><span class="line">  Obj o2;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> o1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情形 4 返回全局变量</p>
<p>当返回的对象不是在函数内创建的时候，是无法进行返回值优化的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Obj g_obj;</span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>();</span><br><span class="line">  std::cout &lt;&lt; &amp;obj &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情形 5 返回函数参数</p>
<p>与返回全局变量类似，当返回的对象不是在函数内创建的时候，是无法执行返回值优化的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj o;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>(o);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in main &quot;</span> &lt;&lt; &amp;obj &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情形 6 返回成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">   Obj obj;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Wrapper</span>().obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>();</span><br><span class="line">  std::cout &lt;&lt; &amp;obj &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情形 7 存在赋值行为</p>
<p>(N) RVO 只能在从返回值创建对象时发送，在现有对象上使用 operator=而不是拷贝/移动构造函数，这样是不会进行 RVO 操作的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Return <span class="title">Obj</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  obj = <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。[[#条款 04 确保对象在使用前已被初始化]] 已经为“在单线程环境中合理返回 reference 指向一个 local static 对象”提供了一份设计实例。</li>
</ul>
<h3 id="条款-22-将成员变量声明为-private"><a href="#条款-22-将成员变量声明为-private" class="headerlink" title="条款 22 将成员变量声明为 private"></a>条款 22 将成员变量声明为 private</h3><p>对 class 内所有成员变量声明为 <code>private</code>，<code>private</code> 意味着对变量的封装。但本条款提供的更有价值的信息在于不同的属性控制—— <code>public</code>, <code>private</code> 和 <code>protected</code> ——代表的设计思想。</p>
<p>简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是 private 了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是语法一致性；其次，对变量的封装意味着，可以尽量减小因类型内部改变造成的类外外代码的必要改动。</p>
<p>一旦所有变量都被封装了起来，外部无法直接获取，那么所有类的使用者（我们称为客户，客户也可能是未来的自己，也可能是别人）想利用私有变量实现自己的业务功能时，就必须通过我们留出的接口，这样的接口便充当了一层缓冲，将类型内部的升级和改动尽可能的对客户不可见——不可见就是不会产生影响，不会产生影响就不会要求客户更改类外的代码。因此，一个设计良好的类在内部产生改动后，对整个项目的影响只应是需要重新编辑而无需改动类外部的代码。</p>
<p>我们接着说明，<code>public</code> 和 <code>protected</code> 属性在一定程度上是等价的。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种——用这个类创建对象或者继承这个类以设计新的类——以下简称为第一类客户和第二类客户。那么从封装的角度来说，一个 <code>public</code> 的成员说明了类的作者决定对类的第一种客户不封装此成员，而一个 <code>protected</code> 的成员说明了类的作者对类的第二种客户不封装此成员。也就是说，当我们把类的两种客户一视同仁了以后，<code>public</code>、<code>protected</code> 和 <code>private</code> 三者反应的即类设计者对类成员封装特性的不同思路——对成员封装还是不封装，如果不封装是对第一类客户不封装还是对第二类客户不封装。</p>
<p>请记住：</p>
<ul>
<li>切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性。</li>
<li>Protected 并不比 public 更具封装性。</li>
</ul>
<h3 id="条款-23-优先使用-non-member、non-friend-函数"><a href="#条款-23-优先使用-non-member、non-friend-函数" class="headerlink" title="条款 23 优先使用 non-member、non-friend 函数"></a>条款 23 优先使用 non-member、non-friend 函数</h3><p><strong>一句话总结</strong>：除非函数需要访问对象的内部状态，否则优先设计为非成员函数（而不是成员函数或 friend 函数）。</p>
<p>优点：</p>
<ul>
<li>增加封装性</li>
</ul>
<blockquote>
<p>封装的目标是<strong>隐藏实现细节</strong>，只暴露必要接口。<br>成员函数自动成为 class 接口的一部分（即 <code>public API</code>）；<br>一旦暴露为成员函数，就表示这个操作是这个类“核心功能”的一部分；<br><strong>非成员函数</strong>不属于类本体，可以在<strong>不破坏类内部状态的前提下</strong>使用类。<br><strong>非成员函数更容易与实现细节解耦</strong>，从而保持类的封装性。</p>
</blockquote>
<ul>
<li>提升包裹弹性（Packaging Flexibility）</li>
</ul>
<blockquote>
<p>非成员函数可以放在：不同的命名空间、独立的头文件或工具库、不受类定义和编译单元的直接限制。<br>非成员函数更容易复用、更方便替换或修改、在多个模块/库进行链接时可以避免依赖地狱。</p>
</blockquote>
<ul>
<li>更容易扩展功能</li>
</ul>
<blockquote>
<p>如果需要为第三方类添加新功能，由于不能修改第三方类的源码，所以只能写非成员函数来扩展功能。而如果依赖成员函数，则意味着必须控制类定义，这在现实中经常做不到。<br>非成员函数是 <strong>开放-封闭原则（OCP）</strong> 的体现：对扩展开放、对修改封闭。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Namespace utils &#123;</span><br><span class="line">    <span class="function">Void <span class="title">print</span> <span class="params">(<span class="type">const</span> ThirdPartyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class Rational &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ❌ 错误做法：不应该写为成员函数</span></span><br><span class="line">    Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(<span class="keyword">this</span>-&gt;num * rhs.num, <span class="keyword">this</span>-&gt;den * rhs.den);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 更好做法：非成员函数（通常写在命名空间中）</span></span><br><span class="line">Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                    lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条款-24-若函数的所有参数（包括第一个参数）均需类型转换，则其应该设计为非成员函数"><a href="#条款-24-若函数的所有参数（包括第一个参数）均需类型转换，则其应该设计为非成员函数" class="headerlink" title="条款 24 若函数的所有参数（包括第一个参数）均需类型转换，则其应该设计为非成员函数"></a>条款 24 若函数的所有参数（包括第一个参数）均需类型转换，则其应该设计为非成员函数</h3><p>C++中，如果把一个函数写成成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; other);  <span class="comment">// 成员函数，隐含 this 作为第一个参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会只允许对非第一个参数做隐式类型转换，但对第一个参数（即 <code>this</code> 指向的对象）不做类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Rational result = a * <span class="number">2</span>;    <span class="comment">// OK：2 被隐式转换为 Rational</span></span><br><span class="line">result = <span class="number">2</span> * a;             <span class="comment">// 错！不能隐式将 2 转换为 this 所需的 Rational</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a * 2</code> 会调用成员函数 <code>a.operator*(2)</code> —— 第二个参数能被转换；</li>
<li>但 <code>2 * a</code> 中，左边的 2 需要转换成 Rational，并成为成员函数的调用对象 —— 编译器不允许隐式这样做。</li>
</ul>
<blockquote>
<p>注意，<code>operator*</code> 函数接受的参数为 <code>Rational</code> 对象，<code>a.operator*(2)</code> 之所以能通过编译，是因为发生了隐式类型转换，编译器由 2 构造出一个临时对象，然后将该临时对象作为参数传入了该函数。如果函数声明中加入了 <code>explicit</code> 关键字禁用掉隐式转换，则不论是 <code>a * 2</code> 还是 <code>2 * a</code></p>
</blockquote>
<p>使用非成员函数来写上面例子中的运算符重载则可以解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 实现乘法逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，当一个函数，其所有参数都可能来自不同类型、需要转换时，应使用非成员函数，这样才能获得更大的灵活性和对称性。</p>
<h3 id="条款-25-写出一个不抛异常的-swap-函数"><a href="#条款-25-写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25 写出一个不抛异常的 swap 函数"></a>条款 25 写出一个不抛异常的 swap 函数</h3><p><code>std::swap</code> 的典型实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; lhs, T&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(lhs)</span></span>;</span><br><span class="line">        lhs = rhs;</span><br><span class="line">        rhs = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要类型 <code>T</code> 支持拷贝构造和赋值运算符，<code>std::swap</code> 即可完成置换。不过这里涉及到一次拷贝构造和两次赋值，对于一般的类型而言，这样的操作并没有什么问题，但是对于一些特殊的类型，这样的操作不够高效。考虑以下对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class WidgetImpl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl); <span class="comment">// 深拷贝</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Widget</code> 对象的置换可以通过直接交换 <code>pImpl</code> 指针实现，对 <code>Widget</code> 对象直接执行 <code>std::swap</code> 会发生以下行为：</p>
<ol>
<li><code>T temp = a;</code> → 调用拷贝构造函数 → 复制整个 <code>WidgetImpl</code> 内容</li>
<li><code>a = b;</code> → 调用赋值运算符 → 再复制一次</li>
<li><code>b = temp;</code> → 第三次复制</li>
</ol>
<p>实际上总共发生了三次对于 <code>WidgetImpl</code> 的深拷贝，而置换实际上只需要 <code>pImpl</code> 即可，如果需要让 <code>std::swap</code> 实现这样的行为，需要对 <code>std::swap</code> 进行偏特化。（ C++规定：通常不允许改变 std 命名空间内的任何东西，但是可以为标准 template（如 swap）制造特化版本，使他专属于我们自己的 class）。类似以下实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="comment">// 表明是个模板全特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt; (Widget&amp; lhs, Widget&amp; rhs) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(lhs.pImpl, rhs.pImpl); <span class="comment">// 直接置换pImpl指针,但是由于访问权限会编译失败</span></span><br><span class="line">    &#125;****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的代码并不能通过编译，因为 <code>pImpl</code> 是 <code>Widget</code> 的私有成员，那么如何实现期望的置换呢？答案是在 <code>Widget</code> 内部添加一个 <code>public</code> 的 <code>swap</code> 实现，然后让 <code>std::swap</code> 的特化版本调用这个 <code>public</code> 成员函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl); <span class="comment">// 深拷贝</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">Swap</span> (pImpl, rhs. PImpl);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="comment">// 表明是个模板特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt; (Widget&amp; lhs, Widget&amp; rhs) &#123; <span class="comment">// 为Widget类型提供偏特化（partially specialize）</span></span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs); <span class="comment">// 直接置换pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Widget</code> 和 <code>WidgetImpl</code> 是类模板的话，情况会变得复杂一些，如果直接按照上面代码的想法改写到模板的对应写法，可能会写出类似下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt; (Widget&lt;T&gt;&amp; lhs, Widget&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 C++只允许对类模板（class template）进行部分特化，并不允许对函数模板（function template）进行部分特化。所以这段代码会编译失败。</p>
<blockquote>
<p>Q: 为什么示例是部分特化而不是重载或全特化？<br>  A: 示例代码尝试为 <code>std::swap</code> 提供一个专门用于 <code>Widget&lt;T&gt;</code> 的版本，并且 <code>T</code> 是模板参数。这正是 “部分特化” 的定义：「保留部分模板参数开放，同时对特定的模板参数形式做出适配。」</p>
</blockquote>
<p>如果仍想要在 <code>std</code> 命名空间中提供一个针对 <code>Widget</code> 的模板 <code>swap</code> 函数，一个简单的方法是对 <code>Widget</code> 提供重载版本的 <code>swap</code> 函数（并非偏特化）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="comment">// std::swap 的重载版本</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt; <span class="type">const</span>&amp; lhs, Widget&lt;T&gt; <span class="type">const</span>&amp; rhs)</span> </span>&#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载版本的模板 <code>swap</code> 函数的问题在于，<code>std</code> 是一个特殊的命名空间，其管理规则也比较特殊，代码可以对 <code>std</code> 中的模板进行偏特化，但是不可以添加新的 <code>templates</code>，这是未定义行为。所以可行的方法是：提供一个模板 <code>swap</code> 函数，但是不放在 <code>std</code> 命名空间中，而是放在其他的命名空间中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;; <span class="comment">// 提供成员swap函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样处理之后，在任意位置调用 <code>swap</code> 函数，根据名称查找法则（name lookup rules；更具体地来说是 argument-dependent lookup（实参依赖查找，ADL）），<code>swap</code> 函数会自动调用位于 <code>WidgetStuff</code> 命名空间中的 <code>swap</code> 函数。所以，如果想要让代码在尽可能多的上下文中使用为自定义类型专门设计的 <code>swap</code> 函数，就需要在同一个命名空间中写出成员函数和非成员函数的特化版本 <code>swap</code> 函数。</p>
<p>以上讲的是从 swap 的实现者角度出发的内容，但从调用者的角度也有一个很重要的情况值得探讨，假如一个 function template 中需要置换两个对象值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>那么这里调用的 <code>swap</code> 究竟是哪一个呢？</p>
<ul>
<li>是 <code>std::swap</code> 通用版本？</li>
<li>是专门为 <code>T</code> 类型写在 <code>std</code> 里的某个特化版本（可能存在，也可能不存在）？</li>
<li>是某个为 <code>T</code> 提供的特定 <code>swap</code> 函数？（可能存在，也可能在非 <code>std</code> 命名空间里）</li>
</ul>
<p>其实一般来说，调用者的期望行为其实是：<br>✅ 如果有为 <code>T</code> 提供的特定 <code>swap</code>，优先用它；<br>❎ 如果没有，那就回退到 <code>std::swap</code> 通用版本。</p>
<p>那么如何实现上述期望行为呢，答案是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;       <span class="comment">// 把 std::swap 引入当前作用域</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);      <span class="comment">// 调用最合适的 swap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码能够实现期望行为的原理在于，C++的 ADL 规则规定：如果 <code>T</code> 属于某个命名空间，例如 <code>WidgetStuff::Widget</code>，那么编译器在查找 <code>swap(obj1, obj2)</code> 时，会首先去 <code>WidgetStuff</code> 命名空间里找有没有合适的 <code>swap</code>。同时，<code>using std::swap;</code> 让 <code>std::swap</code> 在当前作用域可见，所以：</p>
<ul>
<li>优先使用 <code>T</code> 所在命名空间里的 swap（ ADL 规则 ）</li>
<li>如果没有找到，就使用 <code>std::swap</code> 的模板实现</li>
<li>如果 <code>std::swap</code> 为 <code>T</code> 做了特化（full specialization），那么使用特化版本</li>
</ul>
<p>错误写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(obj1, obj2);  <span class="comment">// ❌ 错误：强行限定只在 std:: 里找</span></span><br></pre></td></tr></table></figure>
<p>这样写会强迫编译器只在 <code>std</code> 命名空间进行查找，从而失去了使用更高效 T-specific swap 的机会。  </p>
<p>不过，我们仍需要为 <code>std::swap&lt;T&gt;</code> 提供一个特化版本，因为虽然 <code>std::swap</code> 不应该被用户“扩展”，但标准库中仍有代码是这样写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(obj1, obj2);  <span class="comment">// 标准库内部或第三方库写死了 std::swap</span></span><br></pre></td></tr></table></figure>
<p>为了让这些写法也能使用到专门设计的高效版本，仍需要完全特化 <code>std::swap&lt;T&gt;</code>。这种行为是 C++标准所允许的（即可以对 <code>std::swap</code> 的特定类型做 <strong>全特化</strong>），但不能对它做 <strong>重载或偏特化</strong>。</p>
<p>总结，如果我们是类的作者：</p>
<ul>
<li>定义一个成员 <code>swap</code> 函数，高效地交换两个对象。<ul>
<li>建议 <code>noexcept</code>，因为 <code>swap</code> 常被用在强异常安全保障下。</li>
</ul>
</li>
<li>在命名空间里定义非成员 <code>swap(T&amp;, T&amp;)</code>，调用成员 <code>swap</code>。</li>
<li>如果是类（非类模板），可以在 <code>std</code> 命名空间里全特化 <code>std::swap&lt;T&gt;</code>，也调用成员 <code>swap</code>。</li>
</ul>
<p>如果我们是类的使用者，需要使用模板函数交换两个对象，那么应该使用形似下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);  <span class="comment">// ✅ 支持 ADL 和 std::swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款-26-尽可能延后变量定义式的出现时间"><a href="#条款-26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26 尽可能延后变量定义式的出现时间"></a>条款 26 尽可能延后变量定义式的出现时间</h3><p>如果定义了一个变量而其类型带有一个构造函数或者析构函数，那么当出现变量的定义式时，就需要承受构造成本，当变量离开作用域时，就得承受析构成本，即使这个变量最终并未被使用，仍需耗费这些成本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数中过早的定义了 <code>encrypted</code> 变量，如果函数抛出了异常，那么 <code>encrypted</code> 变量并不会被使用到，而仍需承受其构造和析构成本，所以应该延后其定义，将其放在抛异常代码的后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted’s definition until it’s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Using <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted; <span class="comment">// default constructor</span></span><br><span class="line">    encrypted = password; <span class="comment">// assign to encrypted</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[[#条款 04 确保对象在使用前已被初始化]] 中说明了使用默认构造函数进行构造之后再进行复制是低效的，所以上面的代码在效率上仍可提高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally, the best way to define and initialize encrypted</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// import std and check length</span></span><br><span class="line">    <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>; <span class="comment">// define and initialize via copy constructor</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点是，如果一个变量只在循环内使用，那么应该是应该在循环外预先定义一个变量并在每次循环时进行赋值，还是该在循环中每次直接定义一个临时变量使用呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop      // Approach B: define inside loop</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;           <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    W = some value dependent on i;          <span class="function">Widget <span class="title">w</span> <span class="params">( some value dependent on i)</span></span>;</span><br><span class="line">&#125;                                       </span><br><span class="line">    ...                                  ...</span><br><span class="line">&#125;                                       &#125;</span><br></pre></td></tr></table></figure>
<p>这里两种做法的成本时：</p>
<ul>
<li>A：一次构造、一次析构、n 次赋值</li>
<li>B：n 次构造、n 次析构</li>
</ul>
<p>所以，如果 class 的一次赋值成本低于一次构造+一次析构，那么方法 A 是比较高效的，尤其是当 n 很大的时候，否则方法 B 更好。不过方法 A 中 w 的作用域覆盖了整个循环，相比 B 而言，它的可理解性和易维护性要差一些。因此除非（1）明确知道赋值成本低于“构造+赋值”，（2）正在处理代码中效率高度敏感的部分，否则应该使用方法 B。</p>
<h3 id="条款-27-尽量少进行类型转换"><a href="#条款-27-尽量少进行类型转换" class="headerlink" title="条款 27 尽量少进行类型转换"></a>条款 27 尽量少进行类型转换</h3><p>C++的规则设计旨在保证类型错误不可能发生。理论上，如果程序能顺利编译，就意味着它不会对任何对象执行不安全或无意义的操作。这是一个宝贵的保证，我们不应该轻易放弃它。遗憾的是，类型转换会破坏类型系统。这可能导致各种问题，有些容易识别，有些则极其微妙。</p>
<h4 id="类型转换语法回顾"><a href="#类型转换语法回顾" class="headerlink" title="类型转换语法回顾"></a>类型转换语法回顾</h4><ol>
<li>C 风格类型转换：<code>(T) expression</code></li>
<li>函数风格类型转换：<code>T (expression)</code></li>
<li>C++风格类型转换：<code>const_cast</code> 、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>static_cast</code></li>
</ol>
<p>1 和 2 并没有什么差别，只是小括号的位置不同，C++风格的 cast 则各有各的作用：</p>
<ul>
<li><code>const_cast</code> 用来移除变量的常量性</li>
<li><code>dynamic_cast</code> 用来安全完成基类向派生类的向下转型（safe downcasting）。它是唯一无法由旧语法执行的动作，也是唯一可能耗费大量运行成本的转型动作。</li>
<li><code>reinterpret_cast</code> 会执行低级转型，实际转型结果可能取决于编译器，这意味着它不可一致。例如将一个 pointer to int 转型为一个 int，这个转换在低级代码以外很少见。</li>
<li><code>static_cast</code> 用来强迫进行隐式转换。例如将 non-const 转换为 const（[[#条款 03 尽可能使用 const]]），将 pointer-to-base 转换为 pointer-to-derived，但是它无法将 const 转换为 non-const，这只有 const_cast 才能做到。</li>
</ul>
<p>新式类型转换的优点：</p>
<ul>
<li>这种转换容易在代码中识别出来，因而简化“找出类型是在哪里被修改的”（简化问题排查）</li>
<li>类型转换的应用范围越窄，编译器越容易判断出出错的运用。</li>
</ul>
<h4 id="类型转换是有代价的"><a href="#类型转换是有代价的" class="headerlink" title="类型转换是有代价的"></a>类型转换是有代价的</h4><p>许多程序员认为，类型转换其实什么都没有做，只是告诉编译器将某种类型视作另一种类型。但这是错误的观点，任何一个类型转换（不论是显示还是隐式调用的类型转换）往往会让编译器产生运行期执行的代码。比如将 int 转换成 double，这种类型转换肯定会消耗一些运行时成本，因为 int 的底层二进制表达方式就和 double 不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;... &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;  <span class="comment">// 隐式地将 Derived* 转换为 Base*</span></span><br></pre></td></tr></table></figure>
<p>上面的代码建立了一个 Base 指针指向一个 Derived 指针，但有时候两个指针值并不相同，这种情况下会有一个偏移量在运行时作用在 Derived 指针上，用以取得正确的 Base 指针。这个例子说明：单个对象（如 Derived 类型对象）可能拥有多个地址（如通过 Base 指针指向时的地址和通过 Derived 指针指向时的地址），一旦使用多重继承，这种现象几乎必然会出现，即使在单一继承中也有可能出现。需要特别注意的是，偏移量计算只是“有时”需要。不同编译器对对象内存布局和地址计算方式的实现各不相同。因此，即便基于“所了解的内存布局”的强制转换在当前平台有效，也绝不能保证在其他平台同样适用。无数程序员已为此付出过惨痛代价。</p>
<h4 id="类型转换的错误使用"><a href="#类型转换的错误使用" class="headerlink" title="类型转换的错误使用"></a>类型转换的错误使用</h4><p>在有些场景下，需要在派生类的 virtual 函数中调用其基类版本。假设我们有一个 <code>Window</code> 基类和 <code>SpecialWindow</code> 派生类，两者都定义了虚函数 onResize。请注意代码中的类型转换（虽然示例使用新式转换，但改用旧式转换结果不变）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>(); <span class="comment">// 调用基类的实现代码</span></span><br><span class="line">        ... <span class="comment">// 这里进行SpecialWindow的专属行为.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码并非在当前对象上调用 <code>Window::onResize</code> 后再执行 <code>SpecialWindow</code> 的特定操作：它创建 <code>*this</code> 对象基类部分的临时副本并在该部分副本上调用 <code>Window::onResize</code>，然后才在当前对象上执行 <code>SpecialWindow</code> 的特定操作。如果 <code>Window::onResize</code> 修改了当前对象（这种可能性很大，因为 onResize 是非 const 成员函数），实际基类部分被修改的将是副本而非当前对象。若 <code>SpecialWindow::onResize</code> 修改了当前对象，就会导致当前对象处于无效状态：基类部分未被修改而派生类部分已被修改。</p>
<p>上面代码的正确写法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpecialWindow::onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>(); <span class="comment">//此时才是真正的调用基类部分的onResize实现.</span></span><br><span class="line">    ...     <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="慎用-dynamic-cast"><a href="#慎用-dynamic-cast" class="headerlink" title="慎用 dynamic_cast"></a>慎用 <code>dynamic_cast</code></h4><p>许多实现版本的 dynamic_cast 运行效率相当低下。例如至少有一种常见实现方案是基于类名的字符串比较。若对四层单继承体系中的对象执行 dynamic_cast，这种实现方案下每次转换可能需要进行多达四次 strcmp 调用来比较类名。更深的继承层次或多重继承体系的性能开销则更大。某些实现采用这种机制有其原因（主要与支持动态链接有关）。但除了对类型转换保持警惕外，在性能敏感代码中更应慎用 dynamic_cast。在探讨 dynamic_cast 的设计影响之前，有必要指出许多实现版本的 dynamic_cast 运行效率相当低下。例如至少有一种常见实现方案是基于类名的字符串比较。若对四层单继承体系中的对象执行 dynamic_cast，这种实现方案下每次转换可能需要进行多达四次 strcmp 调用来比较类名。更深的继承层次或多重继承体系的性能开销则更大。某些实现采用这种机制有其原因（主要与支持动态链接有关）。但除了对类型转换保持警惕外，在性能敏感代码中更应慎用 dynamic_cast。</p>
<p>(1)何时需要 dynamic_cast?</p>
<p>通常当你想在一个你认定为 derived class 对象上执行 derived class 操作函数时，但是你的手上只有一个指向 base 的指针或引用时，你会想到使用 dynamic_cast 进行转型</p>
<p>(2)如何不做转型，实现上述需求？</p>
<p>通常有两种做法可以解决上述问题：</p>
<ul>
<li>方法一：使用容器，并在其中存储直接指向 derived class 对象的指针 (通常是智能指针)，这样就避免了上述需求。  </li>
<li>方法二：在 base class 内提供 virtual 函数做你想对各个派生类想做的事情。这样可以使得你通过 base class 接口处理“所有可能之各种派生类”。</li>
</ul>
<p>总结：</p>
<ul>
<li>尽可能避免使用类型转换，特别是在性能敏感的代码中要避免 dynamic_cast。如果设计必须使用类型转换，应尝试开发无需转换的替代方案。</li>
<li>当必须使用类型转换时，尽量将其隐藏在函数内部。客户端代码可以调用该函数，而不必在自己的代码中直接使用转换。</li>
<li>优先使用 C++风格的类型转换，而非旧式风格转换。它们更易于识别，且能更明确地表达转换意图。</li>
</ul>
<h3 id="条款-28-避免返回对象内部数据的句柄"><a href="#条款-28-避免返回对象内部数据的句柄" class="headerlink" title="条款 28 避免返回对象内部数据的句柄"></a>条款 28 避免返回对象内部数据的句柄</h3><p>Reference、指针、迭代器系统都是所谓的 handle (句柄，用来获得某个对象)。函数返回一个 handle，随之而来的便是“减低对象封装性”的风险。它也可能导致：虽调用 const 成员函数却造成对象状态被更改的风险。如果返回 handles 指向对象内部成分，则可能带来：常量性上的自相矛盾与悬垂引用问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span>&#123;</span><br><span class="line">    Point ul_hc; <span class="comment">// 左上角</span></span><br><span class="line">    Point lr_hc; <span class="comment">// 右下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point&amp;<span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> pData-&gt;ul_hc;&#125;</span><br><span class="line">    <span class="function">Point&amp;<span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> pData-&gt;lr_hc;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的示例代码中，为了让 <code>Rectangle</code> 对象尽可能小，将定义矩形的点放在了辅助类 <code>RectData</code> 中并存储其指针，根据 [[#条款 20 优先使用 pass-by-reference-to-const 而不是值传递]]，<code>Rectangle</code> 类提供了两个公开函数返回了指向代码底层的 <code>Point</code> 对象的引用。这样的设计可以通过编译，但是这是错误的，因为虽然 <code>upperLeft</code> 和 <code>lowerRight</code> 函数被声明为 <code>const</code> 成员函数，客户仍可以通过其修改 <code>Rectangle</code> 的内部数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>; <span class="comment">// rec is a const rectangle from (0, 0) to (100, 100)</span></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>); <span class="comment">// now rec goes from (50, 0) to (100, 100)</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>Rectangle</code> 的内部成员变量只是存储了一个指向实际数据的指针，上面的代码虽然修改掉了内部数据，但是并没有修改内部数据指针指向，所以并不会产生编译错误。</p>
<p>这给我们带来两个教训。首先，数据成员的封装性取决于返回其引用的函数的最低访问级别。在本例中，虽然 <code>ul_hc</code> 和 <code>lr_hc</code> 本应是 <code>Rectangle</code> 的私有成员，但由于公有函数返回了它们的引用，实际上它们变成了公有成员。其次，如果 <code>const</code> 成员函数返回一个指向存储在对象外部数据的引用，那么该函数的调用者仍然可以修改这些数据（这是 <code>bitwise constness</code> 带来的后果——参见 [[#条款 03 尽可能使用 const]]）。</p>
<p>不过，返回成员函数指针的情况并不常见，因此让我们将注意力转回 Rectangle 类及其 <code>upperLeft</code> 和 <code>lowerRight</code> 成员函数。通过对返回类型添加 const 限定，可以消除我们为这些函数指出的两个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ul_hc; &#125;  </span><br><span class="line">    <span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lr_hc; &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这个修改后的设计，客户端可以读取定义矩形的 Points，但不能修改它们。这意味着将 <code>upperLeft</code> 和 <code>lowerRight</code> 声明为 <code>const</code> 不再具有欺骗性，因为它们不再允许调用者修改对象状态。至于封装性问题，我们原本就打算让客户端看到组成 <code>Rectangle</code> 的 <code>Points</code>，因此这是对封装性的有意识放宽。更重要的是，这种放宽是有限制的：这些函数仅授予读取权限，写入权限仍然被禁止。</p>
<p>即便如此，<code>upperLeft</code> 和 <code>lowerRight</code> 仍然返回指向对象内部数据的句柄，这可能会在其他方面产生问题。特别地，这可能导致悬垂句柄（dangling handles）——即指向已不复存在的对象组成部分的句柄。这类消失对象最常见的来源是函数返回值。</p>
<p>总结：</p>
<ul>
<li>避免返回对象内部数据的句柄（引用、指针或迭代器）。不返回句柄可以增强封装性，帮助 const 成员函数保持 const 性质，并最大限度地减少悬空句柄的产生。</li>
</ul>
<h3 id="条款-29-努力实现异常安全"><a href="#条款-29-努力实现异常安全" class="headerlink" title="条款 29 努力实现异常安全"></a>条款 29 努力实现异常安全</h3><p>假设我们有一个用于表示带背景图的 GUI 菜单类。该类设计用于多线程环境，因此包含一个用于并发控制的互斥锁：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>; <span class="comment">// 更改背景图片</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;                <span class="comment">// 互斥锁</span></span><br><span class="line">    Image* bgImage;             <span class="comment">// 当前背景图</span></span><br><span class="line">    <span class="type">int</span> imageChanges;           <span class="comment">// 背景图修改次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下是该函数的实现：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();                  <span class="comment">// 互斥锁上锁</span></span><br><span class="line">    <span class="keyword">delete</span> bgImage;              <span class="comment">// 删除旧图片</span></span><br><span class="line">    ++imageChanges;              <span class="comment">// 更新计数器</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc); <span class="comment">// 安装新图片</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();                <span class="comment">// 释放互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从异常安全的角度来看，这个函数简直糟糕透顶。异常安全有两个基本要求，而它一个都不满足：  </p>
<ol>
<li><strong>不产生资源泄漏</strong>。上述代码违反了这条原则，因为如果”new Image (imgSrc)”抛出异常，unlock 调用将永远不会执行，导致互斥锁被永久持有。  </li>
<li><strong>不允许数据结构被破坏</strong>。如果”new Image (imgSrc)”抛出异常：  <ul>
<li>BgImage 将指向一个已被删除的对象（空悬指针）  </li>
<li>ImageChanges 已被递增，但实际上并未成功安装新图片</li>
</ul>
</li>
</ol>
<p>这两个要求中，解决资源泄漏的方法比较简单，即使用 [[#条款 14 资源管理类要小心复制行为]]中说明的方法进行资源管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常安全函数的函数必须提供以下三个保证之一：①基本保证：保证对象和数据结构，即保证程序内的任何成员都保持有效状态，但不保证程序状态；举例来说，可以让 <code>changeBackground</code> 函数使得一旦有异常被抛出时， <code>PrettyMenu</code> 对象可以继续拥有原背景图像，或是令它拥有某个默认的背景图像，但客户无法预期哪一种情况。如果想知道，他们恐怕必须调用个成员函数以得知当时的背景图像是什么。②强烈保证：程序状态不改变；也就是说要么程序改变成功，如果失败的话，保持未调用函数之前的状态不变 ③nothrow 保证：承诺绝对不会抛出异常，也就是说能够保证功能一定会被成功完成（作用于内置类型上的所有操作都可做到）。</p>
<p>我们的每一个函数都应该满足异常安全，问题在于需要满足哪一种保证。最好的情况是给出 <code>nothrow</code> 保证，但是我们很难在代码中完全不调用任何一个可能抛出异常的函数，任何使用动态内存的东西（比如 STL 容器）如果无法找到足够的内存满足需求，通常会抛出 <code>bad_malloc</code> 异常（[[#条款 49 了解 new-handler 的行为]]）。总结来说，如果可能的话就让代码提供 <code>nothrow</code> 保证，但是对大部分函数来说，需要在基本保证与强烈保证之间抉择。</p>
<p>就 changeBackground 函数而言，实现强保证并非难事。首先，将 <code>PrettyMenu</code> 的 <code>bgImage</code> 数据成员类型从内置的 <code>Image*</code> 指针改为 [[#条款 13 使用对象管理资源（RAII）]] 所述的智能资源管理指针。坦率地说，仅从防止资源泄漏的角度来看，这就是个明智的选择。而这一改动同时能帮助我们实现强异常安全保证，这再次印证了 [[#条款 13 使用对象管理资源（RAII）]] 的观点：使用对象（如智能指针）管理资源是良好设计的基础。其次，重新调整 <code>changeBackground</code> 中的语句顺序，确保在图像实际被修改后才增加 <code>imageChanges</code> 计数。作为通用准则，在操作确实完成之前，最好不要改变对象状态来标记操作已完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123; ... std::shared_ptr&lt;Image&gt; bgImage; ... &#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc)); <span class="comment">// 用&quot;new Image&quot;表达式的结果替换bgImage的内部指针</span></span><br><span class="line">    ++imageChanges; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不再需要手动删除旧图像，因为智能指针会在内部自动处理。更重要的是，只有当新图像成功创建后，旧图像的删除操作才会执行。更准确地说，只有 <code>new Image(imgSrc)</code> 成功时，<code>std::shared_ptr::reset</code> 函数才会被调用。<code>delete</code> 操作仅在 <code>reset</code> 函数内部使用，因此如果从未进入该函数，<code>delete</code> 就永远不会执行。上面的代码几乎足够让 <code>changeBackground</code> 函数提供异常安全强保证，但美中不足的地方在于参数 <code>imgSrc</code>，如果 <code>Image</code> 构造函数抛出异常，有可能 <code>input stream</code> 的读取记号 <code>read marker</code> 已被移走，而这样的移动对程序其他部分是一种可见的状态改变，所以 <code>changeBackground</code> 函数在解决这个问题之前只能说提供了异常安全基本保证。</p>
<p>另外，有一个实现强异常安全保证的通用设计策略，即拷贝-交换原则（copy and swap），其原则很简单：为打算修改的对象拷贝出一个副本，之后在该副本上进行修改，等到所有改变成功之后，再将修改后的副本与原对象进行一个不抛出异常的 swap（[[#条款 25 写出一个不抛异常的 swap 函数]]）。这样的话，假如修改动作产生了异常，swap 函数尚未得到执行，原对象会自然地保持不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123; </span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage; </span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap; <span class="comment">// see Item 25</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl( *pImpl))</span></span>; <span class="comment">// copy data</span></span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc)); <span class="comment">// modify the copy</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    <span class="built_in">swap</span>(pImpl, pNew); <span class="comment">// swap the new data into place</span></span><br><span class="line">&#125; <span class="comment">// release the mutex</span></span><br></pre></td></tr></table></figure>
<p><code>copy-and-swap</code> 策略是对状态做出“全有或全无”改变的一个好办法，但是它并不能保证整个函数都有异常安全强保证。假设有一个 <code>someFunc</code> 函数使用了 <code>copy-and-swap</code> 策略，但函数内还包括对另外两个函数 <code>f1</code> 和 <code>f2</code> 的调用，若 f 1 或 f 2 未达到强异常安全级别，要使 someFunc 具备强异常安全性将十分困难。例如，假设 <code>f1</code> 仅提供基本保证，那么 <code>someFunc</code> 若要实现强保证，就必须编写代码在调用 <code>f1</code> 前记录整个程序状态，捕获 <code>f1</code> 的所有异常，然后恢复原始状态。即使 <code>f1</code> 和 <code>f2</code> 都具备强异常安全性，情况也未必改善。毕竟当 <code>f1</code> 执行完成后，程序状态可能已发生任意改变，此时若 <code>f2</code> 抛出异常，即使 <code>f2</code> 本身未改变任何状态，程序状态也已不同于 <code>someFunc</code> 被调用时的初始状态。总结来说，异常安全具有木桶效用。</p>
<p>另外，<code>copy-and-swap</code> 策略需要为每个待修改对象创建副本，可能消耗无法或不愿承担的时间与空间成本。强异常安全保证虽极具吸引力，且在实际可行时应予以提供，但并非在所有情况下都具备可行性。当强保证不可行时，必须提供基本保证。实践中会发现，某些函数可以实现强保证，但对其他许多函数而言，效率或复杂度的代价会使强保证难以维系。只要在可行时已尽力提供强保证，那么仅提供基本保证就无可厚非。对多数函数而言，基本保证是完全合理的选择。</p>
<p>总结：</p>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源、或让数据被破坏。根据安全程度可以分为：基本保证型、强保证型、nothrow 型</li>
<li>异常安全强保证往往可以通过 <code>copy and swap</code> 实现，但是并非对所有函数都可实现或具备可行性</li>
<li>异常安全具有木桶效用</li>
</ul>
<h3 id="条款-30-透彻了解-inline"><a href="#条款-30-透彻了解-inline" class="headerlink" title="条款 30 透彻了解 inline"></a>条款 30 透彻了解 inline</h3><ol>
<li>Inline<strong>只是对编译器</strong>的一个<strong>申请</strong>，<strong>不是强制命令</strong>。现代 C++编译器中，inline 与最终函数是否内联没有必然关系，编译器可以对非 <code>inline</code> 函数进行内联展开（如果条件合适）。相反，也可以选择<strong>不对 <code>inline</code> 函数进行内联</strong>（例如函数太复杂、体积太大等）。现代 C++中，<code>inline</code> 的核心语义是允许该函数在多个翻译单元中重复定义（只要定义相同），否则，违反 ODR（One Definition Rule）。</li>
<li>Inlining 函数需考虑 object code 的大小；</li>
<li>隐式 inline：将函数定义于 class 定义式内；显示 inline：在其定义式前加上关键字 inline；</li>
<li>Inline 函数通常一定被置于头文件内，因为 inlining 大部分情况下都是编译期行为；template 通常也被置于头文件内，因为大部分建置环境都是在编译期完成具现化</li>
<li>Template 函数不需要加 inline</li>
<li>慎重决定 inlining 施行范围：将大多数 inlining 限制在小型、被频繁调用的函数身上，以便于日后的调试和二进制升级。</li>
</ol>
<ul>
<li>编译器通常不对“通过函数指针而进行的调用”实施内联，且需考虑后续代码维护用到函数指针的可能；</li>
<li>构造函数和析构函数并不适合用于 inlining，往往会引起代码的膨胀（所不要随便地将构造函数和析构函数的定义体放在类声明中）；</li>
<li>Inline 函数代码如发生改变，所有用到该 inline 函数的程序都必须重新编译；</li>
<li>大部分调试器都不能对 inline 函数进行调试；</li>
</ul>
<p>总结：</p>
<ol>
<li>如果 inline 函数不能增强性能，就避免使用它；</li>
<li>Inline 修饰符用于解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题；</li>
<li>Inline 函数本身不能是直接递归函数；</li>
<li>将成员函数的定义体放在类声明之中（隐式 inline）虽然能带来书写上的方便，但不是一种良好的编程风格；</li>
<li>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用，即 inline 是一种“用于实现的关键字”；声明前可以加 inline 关键字，但不符合高质量 C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</li>
</ol>
<h3 id="条款-31-将文件间的编译依存关系降至最低"><a href="#条款-31-将文件间的编译依存关系降至最低" class="headerlink" title="条款 31 将文件间的编译依存关系降至最低"></a>条款 31 将文件间的编译依存关系降至最低</h3><h4 id="编译依存关系导致的问题"><a href="#编译依存关系导致的问题" class="headerlink" title="编译依存关系导致的问题"></a>编译依存关系导致的问题</h4><p>考虑以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: Person.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Address&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName; <span class="comment">// implementation detail</span></span><br><span class="line">    Date theBirthDate; <span class="comment">// implementation detail</span></span><br><span class="line">    Address theAddress; <span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个给出了 <code>Person</code> 类声明的头文件，这个声明中包含了一些实现细节（成员变量），为了能够通过编译，需要引入 <code>string</code>、<code>Data</code>、<code>Address</code> 类的头文件来提供成员变量的定义，如果这三个头文件中有一个发生了变动，那么编译时每一个引入了变动的头文件以及引入 <code>Person.h</code> 头文件的代码都需要重新编译，这样的连串编译依存关系（cascading compilation dependencies）会极大的增加编译时长。</p>
<h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>如果尝试去掉头文件，只使用前置声明，来解决上述问题，可能会写出下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">string</span>; <span class="comment">// forward declaration (an incorrect one — see below)</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName; <span class="comment">// implementation detail</span></span><br><span class="line">    Date theBirthDate; <span class="comment">// implementation detail</span></span><br><span class="line">    Address theAddress; <span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码存在两个问题：</p>
<ol>
<li><code>std::string</code> 并不是一个 <code>class</code>，而是 <code>basic_string&lt;char&gt;</code> 的类型别名，因此代码中针对 <code>std::string</code> 的前置声明并不正确。</li>
<li>通过前置声明的方式引入类型时，该类型是一个 <code>incomplete type</code>，编译器无法在编译代码时获取成员变量的实际大小，从而也无法得知 <code>Person</code> 类的实际大小，那么当有代码单元中尝试实例化 <code>Person</code> 时，编译器在编译该编译单元时将会失败。</li>
</ol>
<p><code>std::string</code> 由标准库提供，并不可能频繁变动，也不太可能成为编译瓶颈，所以正常引入其头文件即可，而其他的类型则可以通过存储对应类型指针的方式解决 <code>incomplete type</code> 导致的问题，因为虽然类型大小无法得知，指针的大小却是固定的，那么 <code>Person</code> 类的大小就固定住了，不会再产生编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName; <span class="comment">// implementation detail</span></span><br><span class="line">    Date* theBirthDate; <span class="comment">// implementation detail</span></span><br><span class="line">    Address* theAddress; <span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>是否可以用前置声明</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 可以</td>
<td>类成员是指针或引用</td>
</tr>
<tr>
<td>✅ 可以</td>
<td>函数参数或返回值是指针或引用</td>
</tr>
<tr>
<td>❌ 不可以</td>
<td>成员是对象（非指针/引用）</td>
</tr>
<tr>
<td>❌ 不可以</td>
<td>按值传递或返回对象</td>
</tr>
<tr>
<td>❌ 不可以</td>
<td>使用对象成员、继承、多态等</td>
</tr>
</tbody>
</table>
</div>
<h4 id="PImpl-idiom（pointer-to-implementation-惯用法）"><a href="#PImpl-idiom（pointer-to-implementation-惯用法）" class="headerlink" title="PImpl idiom（pointer to implementation 惯用法）"></a>PImpl idiom（pointer to implementation 惯用法）</h4><p><code>pImpl</code> 惯用法是解决上面问题的常用方式，即将所有的实现细节隐藏在一个指针背后。将 <code>class</code> 切分成两个，一个只提供接口，另一个负责实现该接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// stl components, shouldn&#x27;t be forward-declared</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// for std::unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>; <span class="comment">// forward decl</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// forward decl</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; <span class="comment">// forward decl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// ptr to implementation;</span></span><br><span class="line">    std::unique_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>一个完整示例</p>
<p><code>student.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> Id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 因为此处智能指针使用的是 unique_ptr ，它为了保证高效性，</span></span><br><span class="line"><span class="comment">     * 其删除器是自身的一部分，它必须保证 raw pointer 为 complete 对象。</span></span><br><span class="line"><span class="comment">     * 由于编译器默认生成的析构函数是 inline ，</span></span><br><span class="line"><span class="comment">     * 此时 Impl 所指之物仅仅是前置声明，是一个 non-complete 对象，所以会报错。</span></span><br><span class="line"><span class="comment">     * 因此如果使用 unique_ptr 而不是 shared_ptr 实现 Impl 时，</span></span><br><span class="line"><span class="comment">     * 不要使用默认的析构行为，请自行额外实现。</span></span><br><span class="line"><span class="comment">     * 因为shared_ptr不使用自身的 deleter，无需这种保证。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Student</span> (<span class="type">const</span> Student&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Student&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Student</span>(Student&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span>=(Student&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> Id)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;StudentImpl&gt; Impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>student.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StudentImpl</span>(<span class="type">int</span> mId) &#123;</span><br><span class="line">        Id = mId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StudentImpl</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">StudentImpl</span>(<span class="type">const</span> StudentImpl&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    StudentImpl&amp; <span class="keyword">operator</span>=(<span class="type">const</span> StudentImpl&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">StudentImpl</span>(StudentImpl&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    StudentImpl&amp; <span class="keyword">operator</span>=(StudentImpl&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetId</span><span class="params">(<span class="type">int</span> mId)</span> </span>&#123;</span><br><span class="line">        Id = mId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetId</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> Id): <span class="built_in">Impl</span>(std::<span class="built_in">make_unique</span>&lt;StudentImpl&gt;(Id)) &#123;&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::SetId</span><span class="params">(<span class="type">int</span> Id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Impl-&gt;<span class="built_in">SetId</span>(Id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::GetId</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Impl-&gt;<span class="built_in">GetId</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Student <span class="title">John</span><span class="params">(<span class="number">233</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; John.<span class="built_in">GetId</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    John.<span class="built_in">SetId</span>(<span class="number">666</span>);</span><br><span class="line">    std::cout &lt;&lt; John.<span class="built_in">GetId</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分离声明与定义"><a href="#分离声明与定义" class="headerlink" title="分离声明与定义"></a>分离声明与定义</h4><p>不论是前置声明还是 pImpl，其实都是在用 <code>声明的依赖关系</code> 替代 <code>定义的依存关系</code>，这正是编译依存性最小化的本质：让头文件尽可能 <code>self-sufficient</code>，如果做不到，则对其他文件内的 <code>声明</code>（而非 <code>定义</code>）进行依赖。</p>
<ul>
<li><strong>如果可以使用指针或引用，就不要直接定义。</strong> 如果只使用指针或引用，则可以通过前置声明的方式定义出指向该类型的指针或引用；但如果定义某类型的变量，则需要用到该类型的定义式。</li>
<li><strong>如果可以，尽量使用 <code>class声明</code> 替代 <code>class定义</code></strong>。比如，当声明某一个函数而该函数用到某个 <code>class</code> 时，其实并不需要该 <code>class</code> 的定义。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>; <span class="comment">// forward decl</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Data d)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>为声明和定义提供不同的头文件。</strong> 为了严格遵守上述准则，需要两个头文件，一个用于声明，一个用于定义。当前，这两个头文件必须保持一致性，如果有个声明被改变了，两个文件都得改变。实际使用时，总是 <code>#include</code> 所提供的声明文件而不是手工前置声明若干函数。按照命名惯例，这个只提供声明的头文件常以 <code>fwd</code> 结尾，比如 C++标准库中的 <code>iosfwd</code> 包含了 <code>iostream</code> 各组件的声明，对应的定义则分布在若干不同的头文件内，包括 <code>sstream</code>、<code>streambuf</code>、<code>fstream</code> 和 <code>&lt;iostream&gt;</code></li>
</ul>
<h4 id="Handle-class-与-Interface-class"><a href="#Handle-class-与-Interface-class" class="headerlink" title="Handle class 与 Interface class"></a>Handle class 与 Interface class</h4><p>像上面所述的如 <code>Person</code> 这样使用 <code>pImpl idiom</code> 的类，往往被称为 <code>Handle classes</code>。<code>Person</code> 类所有函数的实现由对应的 <code>impl类</code> 提供。</p>
<p>另一种制造 <code>Handle class</code> 的方式是，让 <code>Person</code> 成为一个抽象基类，称为 <code>Interface class</code>，它通常不带成员变量，也没有构造函数，只有一个虚析构函数以及一组纯虚函数，用来描述整个接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    Virtual std:: <span class="function">string <span class="title">birthDate</span> <span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于 <code>Person</code> 类被做成了抽象类，它无法被示例化，因此客户端在使用 <code>Person</code> 类需要持有其指针或引用，并常常调用一个工厂函数或者虚构造函数，通过动态分配获取实际的 <code>concrete派生类</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Data&amp; birthday,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// create an object supporting the Person interface</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; was born on &quot;</span> &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>() &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">address</span>();</span><br></pre></td></tr></table></figure>
<p><code>concrete派生类</code> 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr) :</span><br><span class="line">         <span class="built_in">theName</span>(name), </span><br><span class="line">         <span class="built_in">theBirthDate</span>(birthday), </span><br><span class="line">         <span class="built_in">theAddress</span>(addr) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// implementations of these</span></span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// functions are not shown, but</span></span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// they are easy to imagine</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>create</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Address&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Handle classes</code> 和 <code>Interface classes</code> 是有成本的，<code>handle class</code> 的每一个访问都要承受一次通过指针进行间接访问的带家，并且多消耗了一个指针大小的内存。另外，动态内存分配也会带来额外开销，以及产生 <code>bad_alloc</code> 异常的可能性。<code>interface classes</code> 由于每个函数都是虚函数，因此每次函数调用都会产生一次简介跳跃的代价，并且每个派生类对象都要存储虚函数表，从而产生内存上的消耗。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>支持编译依存性最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。</li>
<li>程序库头文件应该以完全且仅声明式（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用。</li>
</ul>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款-32-确定-public-继承呈现出泛化关系（is-a）"><a href="#条款-32-确定-public-继承呈现出泛化关系（is-a）" class="headerlink" title="条款 32 确定 public 继承呈现出泛化关系（is-a）"></a>条款 32 确定 public 继承呈现出泛化关系（is-a）</h3><ul>
<li>Public 继承的意思是：<strong>子类是一种特殊的父类</strong>，这就是所谓的“is-a”关系。</li>
<li>在使用 public 继承时，<strong>子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口</strong>。(设计模式中的里氏替换原则: LSP，Liskov Substitution principle)</li>
</ul>
<p>虽然 public 继承意味着 is-a 的关系看似简单，但有时候如果单纯偏信生活经验，会犯错误。例如：</p>
<ul>
<li>🐧不是🐦</li>
</ul>
<p>下面的代码为 Bird 类定义了 fly 接口，并让企鹅继承了 Bird 类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// birds can fly</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123; <span class="comment">// penguins are birds</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果考虑飞行这一特性（或接口），那么企鹅类在继承中就绝对不能用 public 继承鸟类，因为企鹅不会飞，我们要在<strong>编译阶段消除调用飞行接口的可能性</strong>；但如果所关心的接口是下蛋的话，按照我们的法则，企鹅类就可以 public 继承鸟类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;  <span class="comment">//没有声明 fly 函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Bird</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;     <span class="comment">//没有声明 fly 函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Penguin P;</span><br><span class="line"> P.<span class="built_in">fly</span>();  <span class="comment">//编译阶段就会报错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>正方形不是矩形</li>
</ul>
<p>生活经验告诉我们正方形是特殊的矩形，但这并不意味着在代码中二者可以存在 public 的继承关系，矩形具有长和宽两个变量，但正方形无法拥有这两个变量——没有语法层面可以保证二者永远相等，那就不要用 public 继承。</p>
<p>Note：<br>除了 is-a (泛化关系)外，类之间还有两个常见的关系：has-a (聚合关系)和 is-implemented-in-terms-of 关系，这些关系将在 [[#条款 38 通过复合塑造出 has-a 或 is-implemented-in-terms-of 关系]] 和 [[#条款 39 小心谨慎地使用 private 继承]] 中讨论。</p>
<p>总结：</p>
<ul>
<li>Public 继承意味 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</li>
<li>在确定是否需要 public 继承的时候，我们首先要搞清楚<strong>子类是否必须拥有父类每一个特性</strong>，如果不是，则无论生活经验是什么，都不能视作”is-a”的关系。<strong>public 继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。</strong></li>
</ul>
<h3 id="条款-33-避免继承中的名称遮掩"><a href="#条款-33-避免继承中的名称遮掩" class="headerlink" title="条款 33 避免继承中的名称遮掩"></a>条款 33 避免继承中的名称遮掩</h3><h4 id="什么是名称遮掩"><a href="#什么是名称遮掩" class="headerlink" title="什么是名称遮掩"></a>什么是名称遮掩</h4><p>&gt;</p>
<blockquote>
<p>当编译器在 func 的作用域并使用 x 时，它会先在 local 作用域查找是否存在该变量，如果找不到再扩大作用域。显然，编译器会在 local 找到 double x，然后停止查找，这意味着在 local 中使用 x，将总是找到 double x，而非 global 作用域的 int x。这便是我们所说的：名称遮掩（name-hiding）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;   <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">double</span> x = <span class="number">1.1</span>;  <span class="comment">//局部变量</span></span><br><span class="line">   std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承中存在的名称遮掩问题"><a href="#继承中存在的名称遮掩问题" class="headerlink" title="继承中存在的名称遮掩问题"></a>继承中存在的名称遮掩问题</h4><p>当继承的类存在多次重载的虚函数时，也会产生名称遮掩问题。在父类中，假如虚函数 <code>foo()</code> 被重载了两次，可能是由于参数类型重载（<code>foo(int)</code>），也可能是由于 <code>const</code> 属性重载 (<code>foo() const</code>)。如果子类仅对父类中的 <code>foo()</code> 进行了覆写，那么在子类中父类的另外两个实现 (<code>foo(int)</code> , <code>foo() const</code>)也无法被调用，这就是继承中存在的名称遮盖问题——名称在<strong>作用域级别的遮盖是和参数类型以及是否虚函数无关的</strong>，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Derived d;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   d.<span class="built_in">mf1</span>();   <span class="comment">//没问题，调用Derived::mf1</span></span><br><span class="line">   d.<span class="built_in">mf1</span>(x);  <span class="comment">//报错，因为 derived::mf1 遮掩了 base:: mf1 (int) </span></span><br><span class="line">   d.<span class="built_in">mf2</span>();   <span class="comment">//没问题，调用Base::mf2</span></span><br><span class="line">   d.<span class="built_in">mf3</span>();   <span class="comment">//没问题，调用Derived::mf3</span></span><br><span class="line">   d.<span class="built_in">mf3</span>(<span class="number">4</span>);  <span class="comment">//报错，因为 derived::mf3 遮掩了 base::mf3 （double）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="避免名称遮掩的方式"><a href="#避免名称遮掩的方式" class="headerlink" title="避免名称遮掩的方式"></a>避免名称遮掩的方式</h4><h5 id="使用-using-声明"><a href="#使用-using-声明" class="headerlink" title="使用 using 声明"></a>使用 using 声明</h5><p>让 base class 内的某些事物可以在 derived class 作用域中可见。注意使用 using 声明式的权限符为 public，注意不要违反继承时的继承权限。对于 public 继承，并不是所有的函数都被继承，因而不是所有的函数都可以进行声明访问。尝试声明无法访问的函数，编译器会自动报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> Base::mf1; <span class="comment">// 让Base class内所有名为mf1的东西都在Derived作用域内可见</span></span><br><span class="line">   <span class="keyword">using</span> Base::mf3; <span class="comment">// 让Base class内所有名为mf3的东西都在Derived作用域内可见</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用转发函数（forwarding-function）"><a href="#使用转发函数（forwarding-function）" class="headerlink" title="使用转发函数（forwarding function）"></a>使用转发函数（forwarding function）</h5><p>如果使用 public 继承，那么如 [[#条款 32 确定 public 继承呈现出泛化关系（is-a）]] 所述，派生类应当保留基类的所有函数，那么就应该将基类的所有重载版本都使用 using 声明进行引入。但是假设 Derived 以 private 形式继承 Base，而 Derived 唯一想继承的 mf 1 是那个无参数版本。那么这里就不应该再使用 using 声明式来引入该函数了，因为 using 声明式会令继承而来的某给定名称之所有同名函数在 derived class 中都可见，这里可以使用转交函数 (forwarding function)进行解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123; <span class="comment">// 转交函数（forwarding function）</span></span><br><span class="line">      Base::<span class="built_in">mf1</span>();      <span class="comment">// inline</span></span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Derived d;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   d.<span class="built_in">mf1</span>();   <span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">   d.<span class="built_in">mf1</span>(x);  <span class="comment">// 报错，Base::mf1()被遮掩了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>派生类中的名称会隐藏基类中的名称。在公有继承下，这种情况永远不是我们所期望的。</li>
<li>要使被隐藏的名称重新可见，可使用 using 声明或转发函数。</li>
</ul>
<h3 id="条款-34-区分接口继承和实现继承"><a href="#条款-34-区分接口继承和实现继承" class="headerlink" title="条款 34 区分接口继承和实现继承"></a>条款 34 区分接口继承和实现继承</h3><ul>
<li>public 继承其实可以分成：<code>函数接口（function interfaces）</code> 继承和 <code>函数实现（function implementation）</code> 继承。这意味着 derived class 不仅可以有 base class 函数的声明，还可以有 base class 函数的实现。</li>
<li>成员函数的 <code>接口总是会被继承</code>。因为 [[#条款 32 确定 public 继承呈现出泛化关系（is-a）]] 曾说：public 继承是 is-a 的关系，任何可以作用于 base class 的函数也一定可以作用于 derived class。</li>
<li>不同类型的函数代表了<strong>父类对子类实现过程中不同的期望</strong>。</li>
<li>在父类中声明纯虚函数，是为了<strong>强制子类拥有一个接口</strong>，并<strong>强制子类提供一份实现</strong>。</li>
<li>在父类中声明非纯虚函数，是为了<strong>强制子类拥有一个接口</strong>，并<strong>为其提供一份默认实现</strong>。</li>
<li>在父类中声明非虚函数，是为了<strong>强制子类拥有一个接口以及规定好的实现</strong>，并不允许子类对其做任何更改（条款 36 要求我们不得覆写父类的非虚函数）。</li>
</ul>
<blockquote>
<p>在这其中，有可能出现问题的是普通虚函数，这是因为父类的默认实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应<strong>从代码层面提醒子类的设计者做相应的检查</strong>，很可惜，普通虚函数无法实现这个功能。一种解决方案是，在父类中<strong>为纯虚函数提供一份实现</strong>，作为需要主动获取的默认实现，当子类在实现纯虚函数时，检查后明确默认实现可以复用，则只需调用该默认实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查默认实现的适用性。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Airplane</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pure-virtual  子类继承函数接口，强制覆写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//impure-virtual/virtual  子类继承函数接口和默认函数实现，可覆写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//non-virtual   子类继承函数接口和默认函数实现，不可覆写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DefaultFly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span> : <span class="keyword">public</span> Airplane &#123; <span class="comment">//public 子类继承函数接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fly</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者在于<strong>从编译层面提醒子类主动实现接口</strong>，后者则侧重于<strong>给予子类自由度对接口做个性化适配</strong>。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，<strong>保证所有继承体系内能有其一份实现</strong>。  </p>
</li>
<li><p>两个常见错误：</p>
</li>
</ul>
<blockquote>
<p><strong>1. 将所有函数都声明为 non-virtual。</strong><br>这会使得 derived class 没有余裕空间进行特化工作。Non-virtual 函数还会带来析构问题，见 [[#条款 07 为多态基类声明 virtual 析构函数]]。实际上任何 class 如果打算使用多态性质，都会有若干 virtual 函数。如果你关心 virtual 函数的成本，请参考 80-20 法则：一个典型的程序有 80%的执行时间花费在 20%的代码身上。这个法则十分重要，这意味着平均而言你的函数调用中可以有 80%是 virtual，而不冲击程序的大体效率。所以当你担心是否有能力负担 virtual 函数的运行成本时，先关注那举足轻重的 20%代码身上。<br><strong>2. 将所有函数都声明为 virtual。</strong><br>有时候是正确的，比如 interfaces class。然而这也可能是 class 设计者缺乏坚定立场的表现，某些函数就是不该在 derived class 中被重新实现，你就应该把它声明为 non-virtual。</p>
</blockquote>
<p>总结：</p>
<ol>
<li>接口继承和实现继承不同。在 public 继承之下，derived class 总是继承 base class 的接口。</li>
<li>Pure virtual 函数只具体指定接口继承。</li>
<li>简朴的（非纯）impure virtual 函数具体指定接口继承及默认实现继承。</li>
<li>Non-virtual 函数具体指定接口继承以及强制性实现继承。</li>
</ol>
<h3 id="条款-35-考虑虚函数以外的其他选择"><a href="#条款-35-考虑虚函数以外的其他选择" class="headerlink" title="条款 35 考虑虚函数以外的其他选择"></a>条款 35 考虑虚函数以外的其他选择</h3><p>C++的 virtual 函数让我们能方便地实现接口继承与实现继承，但同时也会让我们忽略可能的其他方案。本条款针对于 virtual 函数的功能设计了具有不同优缺点的替代方案。</p>
<h4 id="通过虚函数完成的典型方案"><a href="#通过虚函数完成的典型方案" class="headerlink" title="通过虚函数完成的典型方案"></a>通过虚函数完成的典型方案</h4><p>假设有一款游戏涉及到各式角色的健康情况，但不同角色的健康度是不同的，这时候将计算健康度的函数声明为 virtual 是最直观的设计方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NpcEvil</span>:<span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方式确实非常直观，但从某种意义上说，这种直观性使得我们不会充分考量其他替代方案。为了跳出面向对象设计的思维定式，此条款在这里探讨几种不同的解决思路。</p>
<h4 id="藉由-Non-Virtual-Interface-手法-（NVI）-实现-Template-Method-模式"><a href="#藉由-Non-Virtual-Interface-手法-（NVI）-实现-Template-Method-模式" class="headerlink" title="藉由 Non-Virtual Interface 手法 （NVI） 实现 Template Method 模式"></a>藉由 <code>Non-Virtual Interface</code> 手法 （NVI） 实现 Template Method 模式</h4><blockquote>
<p>有一个有趣的思想流派<strong>主张 virtual 函数应该几乎总是 private</strong>。这个流派建议：<strong>保留 CalculateHealthValue 为 public 成员函数，但让它成为 non-virtual，并调用一个 private virtual 函数（例如 OnCalculateHealthValue）进行实际工作</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> Result= <span class="built_in">OnCalculateHealthValue</span>();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">OnCalculateHealthValue</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NpcEvil</span>:<span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">OnCalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这种设计方式：令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，称为 non-virtual interface （NVI）手法。</span></span><br></pre></td></tr></table></figure>
<p>值得注意的一点，<strong>C++ 允许 derived class 覆写 base class 的 private virtual 方法</strong>。看起来诡异，但这是真的。</p>
<p>优点</p>
<blockquote>
<p>NVI 手法的一个优点是可以在调用 private virtual 函数前后做一些额外的事情，其实这也是封装带来的好处。调用之前可以做的工作：锁定互斥器，制造运转日志记录项，验证 class 约束条件，验证函数先决条件等等。调用之后可以做的工作：互斥器解除锁定，验证函数的事后条件，再次验证 class 约束条件等等。但假如没有这一层封装，直接调用 virtual 函数，就没有任何好办法可以做这些事。</p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>在某些 class 继承体系中，virtual 函数必须调用其 base class 的版本，这就导致 virtual 函数必须是 protected 而不能是 private，有些时候 virtual 函数甚至一定得是 public。在这种情况下，non-virtual 成员函数和 virtual 成员函数都是 public 的，NVI 的 wrapper 手法显然就不成立了。</p>
</blockquote>
<h4 id="通过-std-function-完成策略模式"><a href="#通过-std-function-完成策略模式" class="headerlink" title="通过 std::function 完成策略模式"></a>通过 <code>std::function</code> 完成策略模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//接受一个reference 指向const Character, 并返回int</span></span><br><span class="line">    <span class="keyword">using</span> FCalculateHealthValueFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">const</span> Character&amp;)&gt; ; <span class="comment">//注意 const &amp; 不能隐式转化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Character</span><span class="params">(FCalculateHealthValueFunc InCalculateHealthValueFunc)</span> :</span></span><br><span class="line"><span class="function">                       CalculateHealthValueFunc(InCalculateHealthValueFunc) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CalculateHealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> Result = <span class="built_in">CalculateHealthValueFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCalculateHealthValueFunc</span><span class="params">(FCalculateHealthValueFunc InCalculateHealthValueFunc)</span> </span>&#123;</span><br><span class="line">        CalculateHealthValueFunc = InCalculateHealthValueFunc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FCalculateHealthValueFunc CalculateHealthValueFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NpcEvil</span> : <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NpcEvil</span><span class="params">(FCalculateHealthValueFunc InCalculateHealthValueFunc)</span></span></span><br><span class="line"><span class="function">        : Character(InCalculateHealthValueFunc) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCalculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">CalculateHealthGM</span><span class="params">(<span class="type">const</span> Character&amp; InNpcEvil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CalculateHealthNormal</span><span class="params">(<span class="type">const</span> Character&amp; InNpcEvil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数指针仍然适用</span></span><br><span class="line">    <span class="function">NpcEvil <span class="title">John</span><span class="params">([](<span class="type">const</span> Character&amp;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> <span class="number">100</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; John.<span class="built_in">CalculateHealthValue</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用返回值为 double 的 static member函数</span></span><br><span class="line">    John.<span class="built_in">SetCalculateHealthValueFunc</span>(&amp;FCalculator::CalculateHealthGM);</span><br><span class="line">    std::cout &lt;&lt; John.<span class="built_in">CalculateHealthValue</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FCalculator Calculator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用某对象的 member 函数</span></span><br><span class="line">    John.<span class="built_in">SetCalculateHealthValueFunc</span>(std::<span class="built_in">bind</span>(&amp;FCalculator::CalculateHealthNormal, Calculator, std::placeholders::_1));</span><br><span class="line">    Std:: cout &lt;&lt; John.<span class="built_in">CalculateHealthValue</span> () &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>Virtual 函数的替换方案包括 NVI 手法以及 Strategy 设计模式的多种形式。NVI 手法自身是一个特殊形式的 Template Method 设计模式。</li>
<li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public 成员。</li>
<li><code>std::function</code> 对象的行为就像一般函数指针。这样的对象可接纳与给定之目标签名式（target signature）兼容的所有可调用物（callable entities）。</li>
</ul>
<h3 id="条款-36-不要重新定义继承而来的非虚函数"><a href="#条款-36-不要重新定义继承而来的非虚函数" class="headerlink" title="条款 36 不要重新定义继承而来的非虚函数"></a>条款 36 不要重新定义继承而来的非虚函数</h3><ul>
<li>如果你的函数<strong>有多态调用的需求</strong>，一定记得把它<strong>设为虚函数</strong>，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。</li>
<li>反之同理，如果一个函数父类没有设置为虚函数，一定不要在子类重载它。</li>
<li>原因：多态的动态调用中，只有虚函数是<strong>动态绑定</strong>，非虚函数是<strong>静态绑定</strong>的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;</span><br><span class="line">D* pD = &amp;x;</span><br><span class="line"></span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();</span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码演示了假如 D 类重新定义其 B 类中的非虚函数会发生什么，非虚函数如 <code>B::mf</code> 和 <code>D::mf</code> 都是静态绑定的，代码中 pB 被定义为一个 pointer-to-B、pD 被定义为一个 pointer-to-D，那么 <code>pB-&gt;mf()</code> 将会调用 <code>B::mf</code>，<code>pD-&gt;mf()</code> 将会调用 <code>D::mf</code>。只有 <code>mf</code> 被修改为虚函数，将函数进行动态绑定，两次函数调用才能如预期一样调用到 <code>D::mf</code>。</p>
<blockquote>
<p>[[#条款 07 为多态基类声明 virtual 析构函数]] 解释为什么<strong>多态性质的 base classes 应该声明 virtual 析构函数</strong>。如果你在多态性质下的 base class 声明了 non-virtual 函数，那么 derived class 便绝不应该重新定义一个继承而来的 non-virtual 析构函数。但即使你没有定义，[[#条款 05 了解 C++默认生成了哪些函数]] 指出<strong>编译器会默认为你生成它</strong>，所以多态性质的 base classes 都需要 virtual 析构函数。因此就本质而言，[[#条款 07 为多态基类声明 virtual 析构函数]] 只不过是本条款的一个特殊案例，尽管它足够重要到单独成为一个条款。</p>
</blockquote>
<h3 id="条款-37-不要重新定义继承而来的默认参数值"><a href="#条款-37-不要重新定义继承而来的默认参数值" class="headerlink" title="条款 37 不要重新定义继承而来的默认参数值"></a>条款 37 不要重新定义继承而来的默认参数值</h3><p>静态绑定和动态绑定的差异</p>
<blockquote>
<p>对象的所谓静态类型（static type），就是它在程序中被声明时采用的类型。对象的所谓动态类型（dynamic type），就是指目前所指对象的类型，可以决定一个对象将会有什么样的动态行为。Virtual 函数是动态绑定的，所以调用一个 virtual 函数时，究竟调用那一份函数实现代码，取决于该对象的动态类型。</p>
</blockquote>
<p>在继承中：</p>
<ul>
<li>不要更改父类非虚函数的默认参数值，其实<strong>不要重载父类非虚函数的任何东西</strong>，不要做任何改变！(见 [[#条款 36 不要重新定义继承而来的非虚函数]])</li>
<li>虚函数不要写默认参数值，子类自然也不要改，<strong>虚函数要从始至终保持没有默认参数值</strong>。</li>
</ul>
<blockquote>
<p>默认参数值是属于<strong>静态绑定</strong>的，而<strong>虚函数属于动态绑定</strong>。虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的默认参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">(std::string Text=<span class="string">&quot;BBB&quot;</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">(std::string Text=<span class="string">&quot;DDD&quot;</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D Derived;</span><br><span class="line">    B* BasePointer = &amp;Derived;</span><br><span class="line">    std::cout &lt;&lt; BasePointer-&gt;<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//BBB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BasePointer 静态类型是 B，动态类型是 D。意味着 ToString 的定义取决于 D，而 ToString 的默认参数值却取决于 B。</span></span><br></pre></td></tr></table></figure>
<p>默认参数值属于<strong>静态绑定</strong>的原因是为了提高<strong>运行时效率</strong>。</p>
<blockquote>
<p>假设默认参数值为动态绑定，编译器就必须要支持某种方式在运行期为 virtual 函数选择适当的默认参数值，这意味着更慢更复杂。</p>
</blockquote>
<p>假如你需要重新定义默认参数值的需求</p>
<blockquote>
<ol>
<li>替换 virtual 函数。[[#条款 35 考虑虚函数以外的其他选择]] 列出了不少 virtual 函数的替换设计。  </li>
<li>如果你真的想让某一个虚函数在这个类中拥有默认参数，那么就把这个虚函数设置成 private，在 public 接口中重制非虚函数，让非虚函数这个“外壳”拥有默认参数值（NVI），当然，这个外壳也是一次性的——在被继承后不要被重载。</li>
</ol>
</blockquote>
<p>总结：</p>
<ul>
<li>绝对不要重新定义一个继承而来的默认参数值，因为默认参数值都是静态绑定，而 virtual 函数——你唯一应该覆写的东西——却是动态绑定。</li>
</ul>
<h3 id="条款-38-通过复合塑造出-has-a-或-is-implemented-in-terms-of-关系"><a href="#条款-38-通过复合塑造出-has-a-或-is-implemented-in-terms-of-关系" class="headerlink" title="条款 38 通过复合塑造出 has-a 或 is-implemented-in-terms-of 关系"></a>条款 38 通过复合塑造出 has-a 或 is-implemented-in-terms-of 关系</h3><ul>
<li>两个类的关系除了继承之外，还有“一个类的对象可以作为另一个类的成员”，我们称这种关系为“类的复合”</li>
<li>Public 继承是一种 is-a 的意义，复合也有它们的意义。复合意味着 has-a（有一个）或 is-implemented-in-terms-of （根据某物实现出）。</li>
<li><code>is-a</code> 和 <code>is-implemented-in-terms-of</code>  的区别：</li>
</ul>
<blockquote>
<p>这两种关系其实是在不同领域的表现，如果对象只是你所塑造的世界中的某个物品，某些人物等，那这样的对象就属于应用域部分，如果对象需要负责你所塑造世界的细节部分，是规则的制定者和执行者，那这样的对象就属于实现域部分。当对象处于应用域，它就是 has-a 的关系，当对象处于实现域，它就是 is-implemented-in-terms-of 的关系。<br>请牢记“is-a”关系的唯一判断法则，一个类的全部属性和接口是否必须<strong>全部</strong>继承到另一个类当中？另一方面，“用一个工具类去实现另一个类”这种情况，是需要对工具类进行<strong>隐藏</strong>的，比如人们并不关心你使用 stack 实现的 queue，所以就藏好所有 stack 的接口，只把 queue 的接口提供给人们用就好了，而红芯浏览器的开发者自然也不希望人们发现 Google Chrome 的内核作为底层实现工具，也需要“藏起来”的行为。</p>
</blockquote>
<ul>
<li>什么情况下我们应该用类的复合？<br>当某一个类“拥有”另一个类对象作为一个属性（has-a），比如学生拥有铅笔、市民拥有身份证，一个人可以有名字，有地址，有手机号码等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;  <span class="comment">//复合对象</span></span><br><span class="line">    Address&amp; Address;</span><br><span class="line">    PhoneNumber&amp; VoiceNumber;</span><br><span class="line">    PhoneNumber&amp; FaxNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>“一个类根据另一个类实现”(is-implemented-in-terms-of )。比如“用 stack 实现一个 queue”，更复杂一点的情况可能是“用一个老版本的 Google Chrome 内核去实现一个红芯浏览器”。再比如用 list 对象实现一个 sets</p>
<p>这里以 list 对象实现一个 sets 为例， <strong>set 成员函数可大量倚赖 list 及标准程序库其他部分提供的机能来完成：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(<span class="type">const</span> T&amp; Item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; Item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">const</span> T&amp; Item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; Rep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">Contains</span>(<span class="type">const</span> T&amp; Item) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">bool</span> Result=std::<span class="built_in">find</span>(Rep.<span class="built_in">begin</span>(),Rep.<span class="built_in">end</span>(),Item)!=Rep.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> T&amp; Item) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Contains</span>(Item)) &#123;</span><br><span class="line">        Rep.<span class="built_in">push_back</span>(Item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> T&amp; Item) &#123;</span><br><span class="line">    <span class="keyword">typename</span> std::list&lt;T&gt;::iterator It=std::<span class="built_in">find</span>(Rep.<span class="built_in">begin</span>(),Rep.<span class="built_in">end</span>(),Item);</span><br><span class="line">    <span class="keyword">if</span> (It!=Rep.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Rep.<span class="built_in">erase</span>(Item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">Size</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显然，set 和 list 的关系是 is-implemented-in-terms-of，而不单单是 has-a 的关系。</span></span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>复合（composition）的意义和 public 继承完全不同。</li>
<li>在应用域（application domain），复合意味 has-a （有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。</li>
</ul>
<h3 id="条款-39-小心谨慎地使用-private-继承"><a href="#条款-39-小心谨慎地使用-private-继承" class="headerlink" title="条款 39 小心谨慎地使用 private 继承"></a>条款 39 小心谨慎地使用 private 继承</h3><p>[[#条款 32 确定 public 继承呈现出泛化关系（is-a）]] 中说到<strong>public 继承是一种 is-a</strong>关系。在这种继承体系下，编译器在必要时刻（为了让函数调用成功）会将 derived class 转换为 base class 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line">​</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">eat</span>(p); <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">eat</span>(s); <span class="comment">// 没问题，这里编译器将Student暗自转换为Person类型。</span></span><br></pre></td></tr></table></figure>
<p>Private 继承的两个行为</p>
<ul>
<li>如果 derived class 和 base class 是 <strong>private 继承</strong>，那么从 derived class 到 base class 的<strong>转换将失败</strong></li>
<li>在<strong>private 继承</strong>下，base class 的成员无论是 private、protected 还是 public，继承后<strong>都会变为 private</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> Person &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line">​</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">eat</span>(p); <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">eat</span>(s); <span class="comment">// 错误！！！s是private继承，编译器无法转换。</span></span><br></pre></td></tr></table></figure>
<p>Private 继承的意义</p>
<ul>
<li>private 继承意味着：is-implemented-in-terms-of （根据某物实现出）。Private 继承可以看作纯粹是 <code>为了实现细节</code>，它需要的不是类似 public 继承可以向外提供接口，仅仅是为了让 derived class 采用 base class 中已经具备的某种特性。Derived 和 base 之间并没有什么直接意义上的联系。</li>
</ul>
<p>那么当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与 private 继承中做选择呢？</p>
<ul>
<li>尽可能用复合，<strong>除非必要，不要采用 private 继承</strong>。</li>
<li>当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择 private 继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。</li>
</ul>
<p>案例一：能用复合，就不要用 private</p>
<blockquote>
<p>假设我们需要写一个 Widget（控件）。这个控件需要按某一频率定时检查 Widget 的某些信息，换句话说需要定时地调用某个函数。为了少写新的代码，我们在其他程序中翻到了一个 Timer class。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个定时器的功能是每隔一段时间就调用一次 onTick 函数。<br>为了让 Widget 重新定义 virtual 内的 virtual 函数，Widget 必须继承自 Timer。但此时不能使用 public 继承，<strong>因为 Widget 并不是个 Timer</strong>，所以我们必须以 private 形式继承 Timer。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">private</span> Timer </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但<strong>private 继承并不是唯一的选择方案</strong>，我们可以<strong>使用复合</strong>来替代这个方案。<br>只要在 Widget 内声明一个<strong>嵌套式 private class</strong>, 后者以 public 形式继承 Timer 并重新定义 onTick, 然后在 Widget 内放一个这种类型的对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//private的</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span> : <span class="keyword">public</span> Timer </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;  <span class="comment">//本应被目标类覆写的方法在嵌套类中实现，这样TargetClass的子类就无法覆写该方法。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>该复合设计相比于 private 继承有两个优点：</strong></p>
<ul>
<li><strong>当 Widget 拥有 derived class 时，你可能同时想阻止 derived class 重新定义 onTick。</strong> 如果是 private 继承（Widget 继承了 Timer），那这个想法就不可能实现。（[[#条款 35 考虑虚函数以外的其他选择]]中指出：derived class 可以重新定义 private virtual 函数，即使派生类中并不能调用它）。但如果 WidgetTimer 是 widget 内部的一个 private 成员并继承 Timer，Widget 的 derived classes 将无法取用 WidgetTimer，因此无法继承它或重新定义它的 virtual 函数。  </li>
<li><strong>降低 widget 的编译依存性。</strong> 如果继承 Timer，当 Widget 被编译时 Timer 的定义必须可见，所以定义 widget 的文件必须 <code>#include &quot;Timer. H&quot;</code>。如果 WidgetTimer 移出 Widget 之外，而 widget 内含指针指向一个 widgetTimer，widget 可以只带一个简单的 WidgetTimer 前置声明。（对大型系统而言非常重要）关于编译依存性的最小化，详见 [[#条款 31 将文件间的编译依存关系降至最低]] 。</li>
</ul>
<p>案例二：一个使用 private 的极端案例</p>
<blockquote>
<p>这种情况真是够激进的，只适用于你所处理的 class 不带任何数据时。这样的 <code>class 不存在任何成员函数或变量</code>。示例：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoWithEmpty</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    FEmpty Empty;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DemoWithEmpty DemoWithEmpty;</span><br><span class="line">    Empty Empty;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(Empty)&lt;&lt;<span class="string">&quot;\n&quot;</span>;  <span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(DemoWithEmpty)&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，一个不含任何成员的 class 的大小居然为 1。因为 C++规定凡是独立对象都必须有非零大小。所以你可以发现 sizeof（Empty）的大小为 1，而且几乎所有的编译器都这样做。至于为什么含一个 int 大小的 class 是 8，这涉及到内存对齐的问题，不必详细讨论。<br>或许你注意到了，独立对象才需要有非零大小，这意味着继承而来的 Empty class 大小可以不受约束:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FEmpty</span> &#123;&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoWithEmpty</span> :<span class="keyword">private</span> FEmpty&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DemoWithEmpty DemoWithEmpty;</span><br><span class="line">    Empty Empty;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(Empty)&lt;&lt;<span class="string">&quot;\n&quot;</span>;  <span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">sizeof</span>(DemoWithEmpty)&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DemoWithEmpty 所用大小正好等于一个 int 的大小，而这种表现就是所谓的 <code>EBO（empty base optimization）空白基类最优化</code>。值得注意的是，EBO 一般在单一继承下才可行。</p>
</blockquote>
<p>尽管有这些例外情况，让我们回到根本。大部分 class 并非 empty，这很少成为你使用 private 继承的理由。只有当你面对需要访问 base class 的 protected 成员或者覆写 virtual 函数时，private 继承才被纳入考虑。当你审视完所有方案，仍然认为 private 继承是最佳方法，才使用它。</p>
<p>总结：</p>
<ol>
<li>Private 继承意味 is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
<li>和复合（composition）不同，private 继承可以造成 empty base 最优化。这对致力于对象尺寸最小化的程序库开发者而言，可能很重要。</li>
</ol>
<h3 id="条款-40-小心谨慎地使用多重继承"><a href="#条款-40-小心谨慎地使用多重继承" class="headerlink" title="条款 40 小心谨慎地使用多重继承"></a>条款 40 小心谨慎地使用多重继承</h3><p>C++社区对多重继承（multiple inheritance MI）持有两类观点。</p>
<blockquote>
<p>单一继承是好的，但多重继承不值得使用。<br>单一继承（single inheritance SI）是好的，多重继承更好。</p>
</blockquote>
<p>两种观点的比较与选择<br>观点一：<strong>多重继承不值得使用</strong></p>
<blockquote>
<p>原因：<strong>多重继承可能会引发歧义（ambiguity）行为。</strong> <strong>解决办法：指明调用</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图书馆可借内容的基类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowAbleItem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>; <span class="comment">// 检查函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个电子小工具类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 检查函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mp3播放器类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span> :</span><br><span class="line"><span class="keyword">public</span> : BorrowAbleItem, </span><br><span class="line"><span class="keyword">public</span> : ElectronicGadget </span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line"><span class="comment">// 这里会引发歧义，mp对象到底调用的是哪个checkout函数？</span></span><br><span class="line">mp.<span class="built_in">checkout</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>疑问：B~class 的 checkOut 函数是 public 的，E~class 的 checkOut 函数是 private 的，理应只有 B~class 的函数是可以调用，那为什么会引发歧义行为？<br>原因：这与<strong>C++的解析机制</strong>有关（与解析（resolving）重载函数调用的规则相符）。在看到是否有个函数可取用之前，C++会首先确认这个函数是不是此调用的最佳匹配，<strong>找出最佳匹配函数后才检验其可取用性</strong>。在该例中，两个 checkOuts 有相同的匹配程度（因此才造成歧义），没有所谓最佳匹配。因此<strong>ElectronicGadget:: checkOut 的可取用性也就从未被编译器审查</strong>(是不是 public 对该问题也就没有影响, 还没到这一步就错了)。</p>
</blockquote>
<p><strong>解决方法</strong>：如下调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定调用BorrowAbleItem的checkOut函数。</span></span><br><span class="line">mp.BorrowAbleItem::<span class="built_in">checkOut</span>();</span><br><span class="line"><span class="comment">// 错误行为！！！通过最佳匹配检查后发现，这个函数是个private函数。</span></span><br><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>原因二：要命的“钻石型多重继承” 解决办法：virtual 继承</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>这种继承体系必须面对的一个问题是：<strong>是不是打算让 File class 内的成员变量经过每一条路径被复制？</strong></p>
<p>总结：</p>
<ol>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li>
<li>Virtual 继承会增加大小，速度，初始化（赋值）复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具有实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及 <strong>“public 继承某个 Interface class”</strong>  和 <strong>“private 继承某个协助实现的 class”</strong> 的组合。</li>
</ol>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="条款-41-了解隐式接口和编译器多态"><a href="#条款-41-了解隐式接口和编译器多态" class="headerlink" title="条款 41 了解隐式接口和编译器多态"></a>条款 41 了解隐式接口和编译器多态</h3><p><strong>显式接口</strong>和<strong>运行期多态</strong></p>
<blockquote>
<p>面向对象的世界总是以显式接口和运行期多态解决问题。</p>
</blockquote>
<p>显式接口的构成<strong>：</strong> 函数名称，参数类型，返回类型，常量性也包括编译器产生的 copy 构造函数和 copy assignment 操作符。( 函数的签名式 )</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>:<span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Special&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NormalWidget</span>:<span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Normalize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Normal&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BeginPlayWithWidget</span><span class="params">(Widget&amp; InWidget)</span> </span>&#123;</span><br><span class="line">    InWidget.<span class="built_in">Normalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpecialWidget SpecialWidget;</span><br><span class="line">    NormalWidget NormalWidget;</span><br><span class="line">    <span class="built_in">BeginPlayWithWidget</span>(SpecialWidget); <span class="comment">//Special</span></span><br><span class="line">    <span class="built_in">BeginPlayWithWidget</span>(NormalWidget); <span class="comment">//Normal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样说 BeingPlayWithWidget 函数中的 InWidget</p>
<ul>
<li>由于 InWidget 类型被声明为 Widget，所以 InWidget 必须支持 Widget 接口。我们可以在源码中找到这个接口，看看它们是什么样子，所以我们称之为一个<strong>显式接口</strong>（explicit interface），也就是它在源码中的确可见。</li>
<li>由于 Widget 的 BeingPlayWithWidget (或者说某些成员函数)函数是 virtual ，InWidget 将对此函数的调用表现出<strong>运行期多态</strong>（runtime polymorphism），也就是说将<strong>在运行期根据 InWidget 的动态类型决定究竟调用哪个函数。</strong></li>
</ul>
<p><strong>隐式接口</strong>和<strong>编译期多态</strong></p>
<blockquote>
<p>Templates 及泛型编程的世界，与面向对象的世界有根本的不同。在此世界显式接口和运行期多态仍然存在，但重要性降低。</p>
</blockquote>
<p>隐式接口的构成： 有效表达式（valid expression）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BeginPlayWithWidgetTemplate</span><span class="params">(T&amp; InT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InT.<span class="built_in">Size</span>() &gt; <span class="number">0</span> &amp;&amp; InT != EClassType::None) &#123;</span><br><span class="line">        InT.<span class="built_in">Normalize</span>();</span><br><span class="line">        std::cout &lt;&lt; InT.<span class="built_in">Size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 InT 来说</p>
<ul>
<li>InT 必须支持哪一种接口，是由函数体中对 InT 的操作决定的。从本例来看，InT 的类型 T 必须要支持 Normalize 、Size、不等比较等操作。看表面可能并非完全正确，但这组操作对于 T 类型的参数来说，是一定要支持的<strong>隐式接口</strong>（implicit interface）。</li>
<li>凡是涉及 InT 的任何函数调用，例如 operator&gt; 和 operator != 有可能造成 template 的具现化，使得这些调用得以成功，这样的行为发生在编译器。以<strong>不同的 template 参数具现化 function templates</strong> 会导致调用不同的函数，这便是所谓的<strong>编译期多态</strong>（compile-time polymorphism）。</li>
</ul>
<blockquote>
<p>纵使你从未用过 templates，应该不陌生“运行期多态”和“编译期多态”之间的差异，因为它类似于“哪一个重载函数该被调用”（发生在编译期）和“哪一个 virtual 函数该被绑定”（发生在运行期）之间的差异。</p>
</blockquote>
<p>隐式接口与显示接口不同，它不基于函数签名式，而是由<strong>有效表达式（valid expression）</strong> 构成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BeginPlayWithWidgetTemplate</span><span class="params">(T&amp; InT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InT.<span class="built_in">Size</span>() &gt; <span class="number">0</span> &amp;&amp; InT != EClassType::None) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例子中， T 类型的隐式接口有这些约束：</p>
<blockquote>
<ol>
<li>T 必须提供名叫 Size 的成员函数，该函数返回一个整数值；  </li>
<li>T 必须支持 operator!= 函数，用来与两个 T 对象，这里假设 EClassType 为 T 类型；<br>得益于操作符重载（operator overloading）带来的可能性，这两个约束都不需要满足。是的，T 必须支持 size 成员函数，然而这个函数也可能从 base class 继承而得。这个成员函数不需返回一个整数值，甚至不需返回一个数值类型。就此而言，它甚至不需要返回一个定义有 operator&gt;的类型！它唯一需要做的是返回一个类型为 x 的对象，而 x 对象加上一个 int（10 的类型）必须能够调用一个 operator&gt;。这个 operator&gt;不需要非得取得一个类型为 x 的参数不可，因为它也可以取得类型 Y 的参数，只要存在一个隐式转换能够将类型 x 的对象转换为类型 y 的对象！<br>同样道理，T 并不需要支持 operator!=，因为以下这样也是可以的：operator！=接受一个类型为 x 的对象和一个类型为 Y 的对象，T 可被转换为 x 而 EClassType 的类型可被转换为 Y，这样就可以有效调用 operator !=。</li>
</ol>
</blockquote>
<p>总结：</p>
<ol>
<li>Classes 和 templates 都支持接口（interfaces）和多态（polymorphism）。</li>
<li>对 classes 而言接口是显式的（explicit），<strong>以函数签名为中心</strong>。多态则是通过 virtual 函数发生于<strong>运行期</strong>。</li>
<li>对 template 参数而言，接口是隐式的（implicit），<strong>奠基于有效表达式</strong>。多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于<strong>编译期</strong>。</li>
</ol>
<h3 id="条款-42-了解-typename-的双重含义"><a href="#条款-42-了解-typename-的双重含义" class="headerlink" title="条款 42 了解 typename 的双重含义"></a>条款 42 了解 typename 的双重含义</h3><p>本条款首先提出一个问题：以下 template 声明式中，class 和 typename 有什么不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br></pre></td></tr></table></figure>
<p>答案：没有不同。</p>
<blockquote>
<p><strong>当我们声明 template 类型参数时， class 和 typename 的意义完全相同。</strong><br>某些程序员喜欢 class，因为可以少打几个字, 有些人比较喜欢 typename ，因为它<strong>暗示参数并非一定是个 class 类型</strong>。</p>
</blockquote>
<p><strong>然而 C++并不总是把 class 和 typename 视为等价</strong>。有时候你一定得使用 typename。为了解其时机，我们必须先谈谈你可以在 template 内指涉（refer to）的两种名称： (嵌套)从属名称和非从属名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintContainer</span><span class="params">(<span class="type">const</span> T&amp; Container)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                           <span class="comment">//注意这不是有效的C++代码</span></span><br><span class="line">    <span class="keyword">if</span> (Container.<span class="built_in">Size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">T::const_iterator <span class="title">iter</span><span class="params">(Container.begin())</span></span>; <span class="comment">//取得第一元素的迭代器  注意 iter</span></span><br><span class="line">        ++iter;                         </span><br><span class="line">        <span class="type">int</span> value=*iter;                    <span class="comment">//将该元素复制到某个int，注意 value</span></span><br><span class="line">        std::cout&lt;&lt;value&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上述代码中强调两个 local 变量：<strong>iter</strong> 和 <strong>value</strong>。<br>iter 的类型是 <code>T::const_iterator</code>，实际是什么取决于 template 参数 T。Template 内出现的名称如果依赖于某个 template 参数，我们就称之为<strong>从属名称</strong>（dependent names）。如果从属名称在 class 内呈嵌套状，我们就称之为<strong>嵌套从属名称</strong>（nested dependent names）。T:: const_iterator 就是这样的名称，实际上它还是一个<strong>嵌套从属类型名称</strong>（nested dependent type name），也就是个<strong>嵌套从属名称</strong>并且<strong>指涉是什么类型</strong>。<br>Value 的类型是 int 。它不依赖于任何 template 参数。我们便称之为非从属名称（non-dependent names）。</p>
</blockquote>
<p>嵌套从属名称可能导致解析（parsing）困难</p>
<blockquote>
<p>在我们知道 T 是什么之前，没有任何办法可以知道 T:: const_iterator 是否为一个类型。而当编译器开始解析 template PrintContainer 时，尚未确知 T 是什么东西。 C++有个规则可以解析（resolve）此一歧义状态：<strong>如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是</strong>。所以缺省情况下嵌套从属名称不是类型。此规则有个例外，稍后我会提到。</p>
</blockquote>
<p>再次回顾上述代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintContainer</span><span class="params">(<span class="type">const</span> T&amp; Container)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                           </span><br><span class="line">    <span class="keyword">if</span> (Container.<span class="built_in">Size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">T::const_iterator <span class="title">iter</span><span class="params">(Container.begin())</span></span>;  <span class="comment">//这个名称被假设为非类型</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在应该很清楚为什么这不是有效的 C++代码了吧。Iter 声明式只有在 T:: const_iterator 是个类型时才合理，但我们并没有告诉 C++说它是，于是 C++假设它不是。若要矫正这个形势，我们必须告诉 C++说 T:: const iterator 是个类型。<strong>只要紧临它之前放置关键字 typename 即可：</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintContainer</span><span class="params">(<span class="type">const</span> T&amp; Container)</span>      <span class="comment">//这是合法的C++代码</span></span></span><br><span class="line"><span class="function"></span>&#123;                                           </span><br><span class="line">    <span class="keyword">if</span> (Container.<span class="built_in">Size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">iter</span><span class="params">(Container.begin())</span></span>;  <span class="comment">//ok</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般性规则很简单：<strong>任何时候当你想要在 template 中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字 typename。</strong>（再提醒一次，很快我会谈到一个例外。）</p>
<p><strong>typename 只被用来验明嵌套从属类型名称</strong>；其他名称不该有它存在。例如下面这个 function template，接受一个容器和一个“指向该容器”的选代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;                 <span class="comment">//允许使用&quot;typename&quot;（或&quot;class&quot;）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> C&amp;container，           <span class="comment">//不允许使用&quot;typename&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">typename</span> C::iterator iter)</span>；        <span class="comment">//一定要使用&quot;typename&quot;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述的 C 并不是嵌套从属类型名称（它并非嵌套于任何“取决于 template 参数”的东西内），所以声明 container 时并不需要以 typename 为前导，但 C:: iterator 是个嵌套从属类型名称，所以必须以 typename 为前导。</p>
</blockquote>
<p>“Typename 必须作为嵌套从属类型名称的前缀词”这一规则的例外是：<strong>typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 member initialization list（成员初值列）中作为 base class 修饰符。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Message</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(std::string InText)</span>: Text(std::move(InText)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetText</span><span class="params">(std::string InText)</span> </span>&#123;</span><br><span class="line">        Text = std::<span class="built_in">move</span>(InText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string Text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T ElementType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> : <span class="keyword">private</span> MessageContainer&lt;T&gt;::ElementType &#123;<span class="comment">//base classes list不使用typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用 typename 表明是一个类型，而不是变量</span></span><br><span class="line">    <span class="comment">//使用 typedef 给过长的类型起别名，方便。</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> MessageContainer&lt;T&gt;::ElementType ElementType; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Printer</span><span class="params">()</span>: MessageContainer&lt;T&gt;::ElementType() &#123;</span> <span class="comment">//mem.init.list中不使用typename</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">typeid</span>(ElementType).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//class Message</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(std::string Text)</span> </span>&#123;</span><br><span class="line">        ElementType::<span class="built_in">SetText</span>(Text);</span><br><span class="line">        std::cout &lt;&lt; ElementType::<span class="built_in">GetText</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TryWithPrinter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;Message&gt; Printer;</span><br><span class="line">    Printer.<span class="built_in">Log</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li>
<li>请使用关键字 typename 标识<strong>嵌套从属类型名称</strong>；但 <strong>不得在 base class lists（基类列）</strong> 或 <strong>member initialization lists（成员初值列）</strong> 内以它作为 base class 修饰符。</li>
</ol>
<h3 id="条款-43-学习处理模板化基类内的名称"><a href="#条款-43-学习处理模板化基类内的名称" class="headerlink" title="条款 43 学习处理模板化基类内的名称"></a>条款 43 学习处理模板化基类内的名称</h3><p>从一个例子入手，假设我们要设计游戏中人物的相关列表，比如 buff 列表，物品列表等等，一个显而易见的设计是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buff</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Buff</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">End</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBuff</span> : <span class="keyword">public</span> Buff &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">End</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlueBuff</span> : <span class="keyword">public</span> Buff &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">End</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T Item)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Add&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        Data.<span class="built_in">insert</span>(Item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Clear&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        Data.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Data.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::set&lt;T&gt; Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerContainer</span> : <span class="keyword">public</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Clear</span>();  <span class="comment">// 在此无法访问 Clear 函数,找不到标识符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PlayerContainer&lt;Buff*&gt; PlayerBuffContainer;</span><br><span class="line">    PlayerBuffContainer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    RedBuff* RedBuffOne = <span class="keyword">new</span> RedBuff;</span><br><span class="line">    BlueBuff* BlueBuffOne = <span class="keyword">new</span> BlueBuff;</span><br><span class="line">    PlayerBuffContainer.<span class="built_in">Add</span>(RedBuffOne);</span><br><span class="line">    PlayerBuffContainer.<span class="built_in">Add</span>(BlueBuffOne);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; PlayerBuffContainer.<span class="built_in">Size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此代码，出现错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clear:找不到标识符!</span><br></pre></td></tr></table></figure>
<p>而出错的原因在于：</p>
<blockquote>
<p>当编辑器遭遇 class template PlayerContainer 时，其实并不知道它究竟继承哪个 class。当然它继承的是 Container ，但其中的 T 是一个 template 参数，<strong>不到后来的具现化，是无法确切知道它是什么</strong>。而如果不知道 T 是什么，就不清楚 class Container 看起来像什么——更确切地说是没办法知道它是否有个 Clear 函数。<br>例如，如果有以下<strong>特化版</strong> class Container （模板全特化）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;                 <span class="comment">//一个全特化的Container</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&lt;Buff*&gt; &#123;   <span class="comment">//它和一般的template相同，区别只在于它删掉了void Clear() 函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(T Item)</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Add&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     Data.<span class="built_in">Insert</span> (Item);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Data.<span class="built_in">size</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=Buff*&gt;</span><br><span class="line"><span class="keyword">class</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，再让我们考虑 derived class PlayerContainer:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerContainer</span> : <span class="keyword">public</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">Clear</span>();   <span class="comment">//如果T==Buff,这个函数不存在</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">ShowAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正如注释所言，<strong>当 base class 被指定为 Container 时，这段代码将不合法！</strong>因为该版本的 Container template 类<strong>被特化</strong>，其中并<strong>不存在 Clear 函数</strong>，且由于编译器会<strong>优先考虑特化版本</strong>，意味着 Container 使用 Buff 具现化时类中只存在 Add、Size 函数，并未提供 Clear 函数。<br>这正是前面所说，为什么 C++ 拒绝在 PlayerContainer 访问 Clear 函数的原因：它知道 base classes templates 有可能被特化，而那个<strong>特化版本可能不提供和一般性 template 相同的接口。因此它往往拒绝在 base classes templates 寻找继承而来的名称</strong>。因此它往往拒绝在 templatized base classes（模板化基类，本例的 Container）内寻找继承而来的名称（本例的 Clear）。</p>
</blockquote>
<p>所以，<strong>我们必须有某种办法令 C++不进入 templatized base classes 观察的行为失效</strong>。幸运的是，我们有三个解决办法：</p>
<blockquote>
<ol>
<li>在 base class template 函数调用动作之前<strong>加上 this-&gt;</strong>。This 指针可以访问所有成员函数。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerContainer</span> : <span class="keyword">public</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span> -&gt; <span class="built_in">Clear</span>();   <span class="comment">//成立，假设Clear将被继承</span></span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2. 使用 using 声明式</strong>。可以告诉编译器进入 base class 作用域寻找函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerContainer</span> : <span class="keyword">public</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Container&lt;T&gt;::Clear; <span class="comment">//告诉编译器，请他假设Clear位于base class内</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="built_in">Clear</span>();   </span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（虽然 using 声明式在这里或在 [[#条款 33 避免继承中的名称遮掩]] 都可有效运作，但两处解决的问题其实不相同。这里的情况并不是 base class 名称被 derived class 名称遮掩，而是编译器不进入 base class 作用域内查找，于是我们通过 using 告诉它，请它那么做。）  </p>
<blockquote>
<p><strong>3. 明确指出被调用函数位于 base class 内。 (不推荐)</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerContainer</span> : <span class="keyword">public</span> Container&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Container&lt;T&gt;::<span class="built_in">Clear</span>();   <span class="comment">//成立，假设Clear将被继承</span></span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但这往往是最不让人满意的一个解法，因为<strong>如果被调用的是 virtual 函数</strong>，上述的明确资格修饰（explicit qualification）会<strong>关闭”virtual 绑定行为”</strong><br>从名称可视点的角度来看，上述每一个解法做的事情都相同：<strong>对编译器承诺 base class template 的任何特化版本都支持其泛化版本所提供的接口。如果承诺未被保证，编译器仍然会报错。</strong></p>
<p>总结：</p>
<ol>
<li><strong>可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 base class 资格修饰符完成。</strong></li>
</ol>
<h3 id="条款-44-将与参数无关的代码抽离-templates"><a href="#条款-44-将与参数无关的代码抽离-templates" class="headerlink" title="条款 44 将与参数无关的代码抽离 templates"></a>条款 44 将与参数无关的代码抽离 templates</h3><ul>
<li><strong>templates 是节省时间和避免代码重复的奇方妙法。</strong></li>
</ul>
<blockquote>
<p>你不再需要键入 20 个类似的 classes 并且每一个都带有 20 个成员函数，你只需要键入一个 class template，留给编译器去具现化那 20 个你需要的相关 classes 即可，而且对于 20 个函数中未被调用的，编译器不会自动生成。这样的技术是不是很伟大，呵呵。</p>
</blockquote>
<ul>
<li>但这也很容易使得<strong>代码膨胀</strong>（code bloat），templates 产出码带着重复，或者几乎重复的代码，数据，或者两者。你可以通过：<strong>共性与变形分析</strong>（commonality and variability analysis）来避免代码膨胀。</li>
</ul>
<blockquote>
<p>这个概念其实你早在使用，即使你从未写过一个 templates。当你编写某个函数时，你明白其中某些部分的实现码和另一个函数的实现码实质相同，你会很单纯的重复它们吗？当然不，你会抽出这两个函数相同的部分，放进第三个函数中，然后令原先两个函数调用这个新函数。也就是说：你分析了两个函数的共性和变形，把公共的部分搬到一个新的函数中去，变化的部分保留在原来的函数不动。对于 class 也是这个道理，如果你明白某些 class 和另一个 class 具有相同的部分，你也会把共性搬到一个新的 class。</p>
</blockquote>
<ul>
<li>Templates 的优化思路也是如此，以相同的方式避免重复，但其中有个窍门。在 non-template 代码中，重复很明确。然而<strong>在 template 代码中，重复是隐晦的，</strong> 毕竟只存在一份 template 代码，所以你必须自己去感受 template 具现化时可能发生的重复。</li>
</ul>
<p>造成代码膨胀的一个典型的例子： <strong>template class 成员依赖 template 参数值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型例子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; m1;</span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; m2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会具现两份非常相似的代码，因为除了一个参数 5，一个参数 10，其他都完全一样</p>
</blockquote>
<p><strong>改进</strong> ：使用带参数的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span>:            <span class="comment">// protected 保证只有本类/子类本身可以调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>  : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123; <span class="comment">// private继承，derived 和base不是is-a关系，base只是帮助实现derived </span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;  <span class="comment">// derived class 会掩盖template base class的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，SquareMatrixBase 只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化。因此对于某给定元素类型，所有矩阵共享同一个 SquareMatrixBase 类。<br>SquareMatrixBase:: invert 只是企图成为“避免派生类代码重复”的一种方法，所以它<strong>用 protected 替换 public</strong>。调用它而造成的额外成本应该是 0 (因此派生类的 invert 调用基类版本的 invert 时是 inline 调用)。这里函数使用 <code>this-&gt;</code>，否则<strong>模板化基类的函数名称会被派生类掩盖</strong>。注意这里是<strong>private 继承</strong>，说明了这里的基类只是为了帮助派生类的实现，不是为了表现 SquareMatrixBase 和 SquareMatrix 的 is-a 关系。</p>
</blockquote>
<p>目前为止一切都好，但还有一些问题没有解决：</p>
<blockquote>
<p>SquareMatrixBase:: invert 如何知道该操作什么数据？<br>虽然它从参数中知道矩阵尺寸，但它如何知道哪个矩阵的数据在哪儿？想必只有派生类知道。<br>派生类如何联络其基类做逆运算动作？</p>
</blockquote>
<p>解决办法： <strong>令 SquareMatrixBase 存储一个指针，指向矩阵数值所在的内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T* pMem) : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是把每一个矩阵的数据放进 heap (也就是通过 new 来分配内存)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span> () :  </span><br><span class="line">         <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),             <span class="comment">//将基类的数据指针设为null</span></span><br><span class="line">         <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])   <span class="comment">// 为矩阵内容分配内存, 将指向该内存的指出存储起来</span></span><br><span class="line">     &#123;<span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>());&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;T[]&gt; pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个条款只讨论由 non-type template parameters (非类型模板参数)带来的膨胀，其实 type parameters (类型参数)也会导致膨胀。</p>
<blockquote>
<ol>
<li>比如在很多平台上，int 和 long 有相同的二进制表述，所以 vector&lt; int&gt;和 vector&lt; long&gt;的成员函数可能完全相同。  </li>
<li>同样的，大多数平台上，所有指针类型都有相同的二进制表述，因此凡模板持有指针者 (比如 list&lt; int&gt;、list&lt; const int &gt;等)往往应该对每一个成员使用唯一一份底层实现。  </li>
<li>也就是说，如果你实现成员函数而它们操作强类型指针（T），你应该令它们调用另一个无类型指针 (void )的函数，由后者完成实际工作。</li>
</ol>
</blockquote>
<p>总结:</p>
<ol>
<li>Templates 生成多个 classes 和多个 functions，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）实现代码共享。</li>
</ol>
<h3 id="条款-45-使用模板成员函数来接受所有兼容类型"><a href="#条款-45-使用模板成员函数来接受所有兼容类型" class="headerlink" title="条款 45 使用模板成员函数来接受所有兼容类型"></a>条款 45 使用模板成员函数来接受所有兼容类型</h3><p>原始指针支持隐式类型转换，派生类指针可以隐式转换为基类指针，非常量指针可以转换为常量指针等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span> : <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span> : <span class="keyword">public</span> Middle &#123;...&#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle; <span class="comment">// Middle*转换为Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom; <span class="comment">// Bottom*转换为Top*</span></span><br><span class="line"><span class="type">const</span> Top* pct2 = pt1; <span class="comment">// Top* 转换为 const Top*</span></span><br></pre></td></tr></table></figure>
<p>但是如果想要用户自定义的智能指针支持以上行为，则会有些麻烦。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* rawptr)</span></span>; <span class="comment">// 通过原始指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;</span><br></pre></td></tr></table></figure>
<p>上面的代码并不能通过编译，因为作为一个模板类，其不同类型的实例其实是完全不同的类型，并没有直接的关系。 <code>SmartPtr</code> 类之间的转换能力，需要借助成员模板函数（member function templates）来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;* other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码中故意将拷贝构造成员模板函数声明为 <code>explicit</code>，因为原始指针类型之间的转换是隐式转换，所以智能指针也应模仿出相应的行为。不过这个代码没有检测 <code>T</code> 和 <code>U</code> 之间是否可以完成合法的类型转换，这种检测在现代 C++中可以借助 SFINAE 或 Concept （C++20）实现，原书中则给出一个简单的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;* other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>()) &#123;...&#125;;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>[[#条款 05 了解 C++默认生成了哪些函数]] 中说明了编译器会为类默认生成哪些函数，并指出如果没有自定义这些函数的情况下，编译器会生成出默认版本的对应实现。上面的代码虽然定义了模板成员函数，不过模板只是一个样例，并没有产生实际的函数，所以编译器仍会提供出默认版本的实现。如果想要自定义出这些函数，不光要声明一个泛型版本的成员函数，还需要手动写出一个非泛型的版本。</p>
<p>总结：</p>
<ul>
<li>使用模板成员函数来生成接受所有兼容类型的函数。</li>
<li>如果声明模板成员函数用于 <code>泛化copy构造</code> 或 <code>泛化赋值函数</code>，需要同时给出泛化版本和非泛化版本。</li>
</ul>
<h3 id="条款-46-需要类型转换时为模板定义非成员函数"><a href="#条款-46-需要类型转换时为模板定义非成员函数" class="headerlink" title="条款 46 需要类型转换时为模板定义非成员函数"></a>条款 46 需要类型转换时为模板定义非成员函数</h3><p>[[#条款 24 若函数的所有参数（包括第一个参数）均需类型转换，则其应该设计为非成员函数]] 中说明了为什么只有非成员函数才能在所有实参上进行隐式类型转换，并给出了相应的代码示例，当使用模板对其进行改写时，情况会变得复杂一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span> (<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>; <span class="comment">// 无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 <code>operator*</code> 函数接收两个 <code>Rational&lt;T&gt;</code> 对象，这要求函数调用时需要推导出 <code>T</code> 的类型，而 <code>oneHalf * 2</code> 这个调用中，由 <code>oneHalf</code> 可以很容易地推导出 <code>T</code> 为 int，而 <code>2</code> 的类型是 <code>int</code> 而并不是某种类型的 <code>Rational&lt;T&gt;</code>，虽然可以通过隐式转换完成，但是模板实参类型推导过程是不会把隐式类型转换考虑在内的。这种转换可以在函数调用中出现，但是这里 <code>T</code> 无法被推导出来，所以也无法生成对应的函数，所以函数实体根本就不存在，自然也无法得到调用。这里的问题可以通过以下代码中的方法解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这里将 <code>operator*</code> 变成了类模板 <code>class Rational&lt;T&gt;</code> 的一个友元函数，当有 <code>Rational&lt;T&gt;</code> 类型对象被构造出来时，就意味着模板类已经被成功实例化，那么 <code>T</code> 在对象构造完成时就被推导完成，友元函数 <code>operator*</code> (接收 <code>Rational&lt;int&gt;</code> 参数)也在模板类实例化的过程中被顺带着实例化出来，那么 <code>oneHalf * 2</code> 这种调用也就可以成功通过编译。</p>
<p>不过代码虽然通过了编译（编译器已经知道调用哪个函数），但是这个函数在模板类中只是得到了声明而并没有得到定义，类外部的 <code>operator*</code> 模板函数与类模板内部的成员函数并没有直接关系，所以会出现链接错误。最简单的解决方法是将函数的定义直接写入模板类内部。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;...&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于函数定义被放在了类中，所以 <code>operator*</code> 模板函数被 <code>inline</code> 。那么当函数体比较复杂时，可能会导致代码膨胀，可以通过令 <code>friend</code> 函数调用辅助函数的方法避免这一点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>当一个模板类相关的某函数需要所有参数都支持隐式类型转换时，将该函数定义为模板类内部的友元函数。</p>
<h3 id="条款-47-使用-traits-classes-表现类型信息"><a href="#条款-47-使用-traits-classes-表现类型信息" class="headerlink" title="条款 47 使用 traits classes 表现类型信息"></a>条款 47 使用 traits classes 表现类型信息</h3><h4 id="如何设计并实现一个-traits-class"><a href="#如何设计并实现一个-traits-class" class="headerlink" title="如何设计并实现一个 traits class"></a>如何设计并实现一个 traits class</h4><ol>
<li>确认将来希望获取的类型相关信息，例如，STL 中容器迭代器的分类（前向，双向，随机等）；  </li>
<li>为该信息选择一个名称，例如 iterator_category；  </li>
<li>提供一个 template 和一组特化版本，内容包含希望支持的类型相关信息。</li>
</ol>
<h4 id="如何使用一个-traits-class"><a href="#如何使用一个-traits-class" class="headerlink" title="如何使用一个 traits class"></a>如何使用一个 traits class</h4><ul>
<li>建立一组重载函数或函数模板，彼此的差异只在于各自的 traits 参数。使得每个函数实现与其接收到的 traits 信息相符。</li>
<li>建立一个控制函数或函数模板，调用上面的函数并传递 trait class 所提供的信息。</li>
</ul>
<p>Note:</p>
<p>这里的使用方法是想通过重载实现编译期 if  else，在 C++17 之后可以直接通过 if constexpr 完成。</p>
<h3 id="条款-48-认识模板元编程"><a href="#条款-48-认识模板元编程" class="headerlink" title="条款 48 认识模板元编程"></a>条款 48 认识模板元编程</h3><p>模板元编程（Template meta-programming, TMP）的作用主要是在编译器进行运算，TMP 是在 1990 s 初期被发现的，注意，它是被发现的而非被发明的。当 C++支持模板时，其实就已经支持 TMP 运算。TMP 已被证明是图灵完备的，使用 TMP 可以完成变量声明、分支、循环、函数调用等操作。不过书中只是大概进行了部分说明，并且成书时仍是 C++98/03 标准，当时的 TMP 常常借助于重载、模板特化等技术实现，在 C++17 之后显得有些过时，这里不进行赘述。</p>
<h2 id="定制-new-和-delete"><a href="#定制-new-和-delete" class="headerlink" title="定制 new 和 delete"></a>定制 new 和 delete</h2><h3 id="条款-49-了解-new-handler-的行为"><a href="#条款-49-了解-new-handler-的行为" class="headerlink" title="条款 49 了解 new-handler 的行为"></a>条款 49 了解 new-handler 的行为</h3><p>当你调用 operator new 函数，程序无法满足某一内存需求时，它会抛出异常。老旧的编译器会返回 null 指针。而抛出异常之前，程序会先调用一个 operator new 错误处理函数，名叫 <code>new-handler</code>。</p>
<blockquote>
<p><strong>new-handler 是一个 typedef</strong>，指向一个无参数值无返回值的函数。我们可以通过 set_new_handler 函数去指定客户想要的 new-handler。<br>Set_new_handler 函数接受一个新的 new-handler 参数，返回被替换掉的 new-handler 函数。</p>
</blockquote>
<p>一个设计良好的 new-handler 函数必须考虑以下几点：</p>
<blockquote>
<ol>
<li><strong>提供更多的可被使用的内存。</strong> 这可以保证下次在 operator new 内部尝试分配内存时能够成功。实现这个策略的一种方法是在程序的开始阶段分配一大块内存，然后在第一次调用 new-handler 的时候释放它。  </li>
<li>安装一个不同的 new-handler。如果当前的 new-handler 不能够为你提供更多的内存，可能另外一个 new-handler 可以。如果是这样，可以在当前的 new-handler 的位置上安装另外一个 new-handler（通过调用 set_new_handler）。下次 operator new 调用 new-handler 函数的时候，它会调用最近安装的。（这个主题的一个变种是一个使用 new_handler 来修改它自己的行为，所以在下次触发这个函数的时候，它就会做一些不同的事情。达到这个目的的一个方法是让 new_handler 修改影响 new-handler 行为的 static 数据, 命名空间数据或者全局数据。）  </li>
<li>卸载 new-handler，也就是为 set_new_handler 传递 null 指针。如果没有安装 new-handler，operator new 在内存分配失败的时候会抛出异常。  </li>
<li>抛出 bad-alloc，或派生自 bad-alloc 的异常。  </li>
<li>没有返回值，<strong>调用 abort 或者 exit</strong>。</li>
</ol>
</blockquote>
<p>有时候你或许希望以不同的方式处理内存分配的情况，比如按不同的 class 进行处理，但是 C++ 并不支持为每一个 class 提供专属版本的 new_handler，好在我们可以模仿这一行为，只要我们为 class 实现自己的 set_new_handler 函数和 operator new 函数即可。</p>
<ul>
<li>对于 set_new_handler ，我们根据参照默认实现即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::new_handler <span class="title">SetNewHandler</span><span class="params">(std::new_handler NewHandler)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::new_handler OldHandler = std::<span class="built_in">set_new_handler</span>(NewHandler);</span><br><span class="line">    CurrentHandler=OldHandler;</span><br><span class="line">    <span class="keyword">return</span> OldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 operator new，我们要做以下事情。</li>
</ul>
<blockquote>
<p>调用标准版 set_new_handler 安装我们自定义的 new-handler，将返回的标准版 new-handler 保存起来。调用标准版 operator new。如果标准版 operator new 异常，那么会调用我们自定义的 new-handler 处理函数。调用标准版 set_new_handler 重新安装标准版的 new-handler。</p>
</blockquote>
<p>为了确保可以重新安装标准版 new-handler，我们可以采用 [[#条款 13 使用对象管理资源（RAII）]] 的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewController</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewController</span><span class="params">(std::new_handler InHandler)</span>: Handler(InHandler) &#123;</span>&#125;</span><br><span class="line">​</span><br><span class="line">    ~<span class="built_in">NewController</span>() &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(Handler);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler Handler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以 operator new 实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> Size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NewController</span>(std::<span class="built_in">set_new_handler</span>(CurrentHandler));</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述代码还是不够简洁，每一个 class 都要自己实现一个 set_new_handler 和 operator new 版本。一个更好的方式是 <code>使用 template 进行模板编程，然后根据不同 class 进行特化和具现化</code>。完整实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">SetNewHandler</span><span class="params">(std::new_handler NewHandler)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::new_handler OldHandler = std::<span class="built_in">set_new_handler</span>(NewHandler);</span><br><span class="line">        CurrentHandler = OldHandler;</span><br><span class="line">        <span class="keyword">return</span> OldHandler;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> Size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">NewController</span>(std::<span class="built_in">set_new_handler</span>(CurrentHandler));</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler CurrentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler  NewHandlerSupport&lt;T&gt;::CurrentHandler = <span class="literal">nullptr</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FDemo</span>:<span class="keyword">public</span>  NewHandlerSupport&lt;FDemo&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TryWithNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FDemo::<span class="built_in">SetNewHandler</span>([]() &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;内存不够啦&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    FDemo *Demos=<span class="keyword">new</span> FDemo[<span class="number">1000123123100000</span>]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，<strong>当 operator new 无法满足内存申请时，它会不断调用 new-handler 函数，直到找到足够内存或异常退出。</strong> 当然，你想说为什么我们需要 template？我们似乎并没有使用到模板参数，是的，T 的确不被需要，我们只是希望，继承自 NewHandlerSupport 的 class 拥有各自的 CurrentHandler 成员。类型参数只是用来区分不同的派生类，<strong>然后 template 机制会自动为每一个 T 具现化一份 CurrentHandler 成员，即使它是 static 的。</strong> 也许你的焦虑还来自于 template class 导致的多重继承，可以先看看 [[#条款 40 小心谨慎地使用多重继承]]。</p>
</blockquote>
<p>总结：</p>
<ol>
<li><strong>set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</strong></li>
<li><strong>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</strong></li>
</ol>
<h3 id="条款-50-了解-new-和-delete-的合理替换时机"><a href="#条款-50-了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50 了解 new 和 delete 的合理替换时机"></a>条款 50 了解 new 和 delete 的合理替换时机</h3><p>替换缺省 new/delete 的三个常见原因：</p>
<blockquote>
<ol>
<li>用来检测运行上的错误。自定义 new 分配超额内存，在额外空间放置特定签名/byte pattern。在 delete 时检查是否不变；反之，肯定存在“overruns”（写入点在分配区块尾部之后）或“underruns”（写入点在分配区块头部之前），delete 也可 log 那个指针。</li>
<li>为了强化效能。缺省版 new/delete 必然比定制版 new/delete 效率低。</li>
<li>为了收集使用上的统计数据。自定义 new/delete 可以收集内存使用习惯与使用寿命。</li>
</ol>
</blockquote>
<p>当一定要写相关 new/delete 代码时，参考成熟的开源代码十分必要（[[#条款 55 让自己熟悉 Boost]]：Boost 的 Pool 库）。</p>
<p>本条款的主题是，<strong>了解何时可在全局性的”class 专属的基础上合理替换缺省的 new 和 delete</strong>。在这之前，先对答案做一些摘要：</p>
<ul>
<li>为了检测运用错误（如前所述）。</li>
<li>为了收集动态分配内存的使用统计信息（如前所述）。</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省内存管理 s 器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位。</li>
<li>为了将相关对象成簇集中。降低“内存页错误”（page fault）的频率，new/delete 的“placement 版本”（[[#条款 52：写了 placement new 也要写 placement delete]]）有可能完成。</li>
<li>为了获得非传统的行为。</li>
</ul>
<p>总结：</p>
<ol>
<li><strong>有许多理由需要写个自定的 new 和 delete，包括改善性能，对 heap 运用错误进行调用，收集 heap 使用信息。</strong></li>
</ol>
<h3 id="条款-51-编写-new-和-delete-需要固守常规"><a href="#条款-51-编写-new-和-delete-需要固守常规" class="headerlink" title="条款 51 编写 new 和 delete 需要固守常规"></a>条款 51 编写 new 和 delete 需要固守常规</h3><ul>
<li>Operator new 应该包含一个无限循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 字节申请。类专属版本还应该处理“比正确大小更大（错误）申请”</li>
<li>Operator delete 应该在收到空指针时不做任何事。类专属版本还应该处理“比正确大小更大（错误）申请”</li>
</ul>
<h3 id="条款-52-写了-placement-new-也要写-placement-delete"><a href="#条款-52-写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52 写了 placement new 也要写 placement delete"></a>条款 52 写了 placement new 也要写 placement delete</h3><ul>
<li><code>placement new</code> 和 <code>placement delete</code> 在 C++ 中并不常见，如果不熟悉也不用太焦虑。请回忆一下 [[#条款 16 成对使用 new 和 delete 时要采用相同形式]] 和 [[#条款 17 以独立语句将 new 对象放入智能指针]]，当你写一个 new 表达式时：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String* Str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>)；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>共有两个函数被调用：一个是用以分配内存的 <strong>operator new</strong>，一个是 <strong>String 的 default 构造函数</strong>。<br>假如第一个函数调用成功，第二个函数却抛出异常。那么运行期系统必须回收第一个函数分配的内存，否则就会发生资源泄漏。在这个时候，客户没有能力归还内存，因为如果 String 构造函数抛出异常，str 尚未被赋值，客户手上也就没有指针指向该被归还的内存。取消步骤一并恢复原样的责任因此落到 C++运行期系统身上。运行期系统就会调用步骤一所调用的 operator new 的相应 operator delete 版本，前提是，<strong>系统必须知道哪一个 operator delete 该被调用</strong>，因为可能存在多个 operator delete 函数（可能接受不同的参数列表）。</p>
</blockquote>
<ul>
<li>对于 <code>placement new/delete</code> ，它们接受额外的参数。当人们谈及 placement new 时，大多数是指具有唯一额外实参 void* 的 operator new，少数时候才是指具有任意额外实参的 operator new。</li>
</ul>
<blockquote>
<p><strong>当抛出异常时，运行期系统会寻找参数个数和类型都与 operator new 相同的某个 operator delete</strong>。比如 operator new 额外接受一个 string 参数，那么 operator delete 也需要提供一个额外的 string 参数。如果并没有这样的 operator delete 函数，那么系统什么也不会做，内存就会泄漏掉。</p>
</blockquote>
<ul>
<li>值得注意的是，<strong>placement delete 只有在 placement new 调用的构造函数异常时才会被系统调用</strong>(即使我们可以显式调用 placement new)。即使你对一个用 placement new 申请出的指针使用 delete，也绝不会调用 placement delete。这意味着额外的参数并不提供实际的作用。</li>
</ul>
<blockquote>
<p>所以，如果要处理 placement new 相关的内存泄漏问题，我们<strong>必须同时提供一个正常版本的 delete 和 placement 版本的 delete</strong>。前者用于构造期间无异常抛出，后者用于构造期间有异常抛出。</p>
</blockquote>
<p>除此之外，还要注意<strong>同名函数遮掩调用的问题</strong></p>
<blockquote>
<p>当你为 class 声明了 placement new 时，客户是无法使用标准版的 operator new 的，因为 derived class 声明的 operator new 会遮掩标准版本和 base class 版本。所以如果你需要的客户在使用标准版本不受影响，也<strong>需要同时提供标准版的定义</strong>。</p>
</blockquote>
<p>满足以上注意事项的一个简单做法是，<code>建立一个 base class</code>，内含所有标准版本的 new/delete，凡是想以写 placement 版本的 class 都可以继承自它，并使用 <code>using 声明式</code> 使得标准版本在类中可见：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FNewDeleteSupport</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> Size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* RawMemory)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(RawMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//placement new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> Size,<span class="type">void</span> *Ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size,Ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* RawMemory,<span class="type">void</span> *Ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(RawMemory,Ptr)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> Size,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; Nothrow)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size,Nothrow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* RawMemory,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; Nothrow)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(RawMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FDemo</span>:<span class="keyword">public</span> FNewDeleteSupport &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FNewDeleteSupport::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> FNewDeleteSupport::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//custom new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> Size,std::string User)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;User&lt;&lt;<span class="string">&quot;使用了内存&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* RawMemory,std::string User)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(RawMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结:</p>
<ol>
<li>当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，你的程序可能会发生隐蔽且时断时续的内存泄漏。</li>
<li>当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们的正常版本。</li>
</ol>
<h3 id="条款-53-不要轻易忽视编译器的警告"><a href="#条款-53-不要轻易忽视编译器的警告" class="headerlink" title="条款 53 不要轻易忽视编译器的警告"></a>条款 53 不要轻易忽视编译器的警告</h3><p>许多程序员习惯性的忽略编辑器警告，这并不是一个好习惯。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span>&#x27;&#x27;</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里希望以 <code>D::f</code> 重新定义 virtual 函数 <code>B::f</code>，但其中有个错误：B 中的 f 是个 const 成员函数，而在 D 中它未被声明为 const。编译器可能会给出这样的警告：<code>warning: D::f() hides virtual B::f()</code><br>如果你认为：“当然，<code>D::f</code> 遮掩了 <code>B::f</code>，那正是想象中该有的事！”<br>那就大错特错了，该编译器试图告诉你声明于 B 中的 f 并未在 D 中被重新声明，而是被整个遮掩了（[[#条款 33 避免继承中的名称遮掩]] 描述为什么会这样）。如果忽略这个编译器警告，几乎肯定导致错误的程序行为，然后是许多调试行为，只为了找出编译器其实早就侦测出来并告诉你的事情。</p>
</blockquote>
<p>因此，需要牢牢记住， <strong>面对警告信息时，你一定要清楚的了解它的真实含义</strong>，然后才可以选择性的处理或者忽略。</p>
<p>总结：</p>
<ol>
<li>严肃对待编译器发出的警告信息。努力在编译器的最高警告级别下无任何警告。</li>
<li>不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原来倚赖的警告信息有可能消失。</li>
</ol>
<h3 id="条款-54-熟悉-STL"><a href="#条款-54-熟悉-STL" class="headerlink" title="条款 54 熟悉 STL"></a>条款 54 熟悉 STL</h3><p>原书中的内容已经过时，关注 C++11 之后的新标准内容即可。</p>
<h3 id="条款-55-让自己熟悉-Boost"><a href="#条款-55-让自己熟悉-Boost" class="headerlink" title="条款 55 让自己熟悉 Boost"></a>条款 55 让自己熟悉 Boost</h3><p><code>Boost</code> 库是一个优秀的，可移植的，开源的 <code>C++</code> 库，它是由 <code>C++</code> 标准委员会发起的，其中一些内容已经成为了下一代 <code>C++</code> 标准库的内容，在 <code>C++</code> 社区中影响甚大，是一个不折不扣的准标准库，它的功能十分强大，弥补了 <code>C++</code> 很多功能函数处理上的不足。很多 <code>boost</code> 中的库功能堪称对语言功能的扩展，其构造用尽精巧的手法，不要贸然的花费时间研读。<code>boost</code> 另外一面，比如 <code>Graph</code> 这样的库则是具有工业强度，结构良好，非常值得研读的精品代码，并且也可以放心的在产品代码中多多利用。</p>
<p>Boost 程序库涉及的领域很多：</p>
<ul>
<li>字符串与文本处理，比如格式化字符串，正则表达式等。</li>
<li>容器，覆盖接口与 STL 相似的数组，bitsets，以及多维数组。</li>
<li>函数对象和高级编程。</li>
<li>泛型编程，覆盖大量的 traits classes。</li>
<li>模板元编程，TMP 程序库。</li>
<li>数学和数值，包括有理数，八元数和四元数，公约数和少见的多重计算，随机数等等。</li>
<li>正确性和测试，覆盖用来将隐式模板接口形式化的程序库。</li>
<li>数据结构，覆盖类型安全的 unions，tuples。</li>
<li>语言间的支持，包括允许 C++ 和 Python 的无缝互操作性。</li>
<li>内存，覆盖 Pool 程序库，包括智能指针等。</li>
<li>杂项，包括 CRC 检验，日期和时间处理，文件系统操纵等。</li>
</ul>
<p>总结：</p>
<ol>
<li>Boost 是一个社群，也是一个网站。致力于免费，源码开放，同行评审的 C++ 程序库开发。 Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li>
<li>Boost 提供许多标准库以及其他许多程序库的实现。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/04/12/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2%E8%BF%90%E8%A1%8CApollo9.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/12/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2%E8%BF%90%E8%A1%8CApollo9.0/" class="post-title-link" itemprop="url">WSL2运行Apollo9.0</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-12 16:59:11" itemprop="dateCreated datePublished" datetime="2024-04-12T16:59:11+08:00">2024-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>328</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://apollo.baidu.com/docs/apollo/9.0/md_docs_2_xE5_xAE_x89_xE8_xA3_x85_xE6_x8C_x87_xE5_x8D_x97_2_xE6_xBA_x90_xE7_xA0_x81_xE5_xAE_x89_c6622abe953930b2197ae66df0a51dcd.html">Apollo官方文档-源码安装说明</a></li>
<li><a target="_blank" rel="noopener" href="https://apollo.baidu.com/community/article/1212">Apollo官方社区文章-40系列显卡新镜像支持</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ApolloAuto/apollo/issues/14821">Apollo Github Issue-14821 使用4090显卡编译报错</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ApolloAuto/apollo/issues/14478">Apollo Github Issue-14478 Fail to build apollo in WSL2 ( error code: 14, error message: ‘Socket closed’)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-container-toolkit/issues/289">Apollo Github Issue-289 WSL2: nvidia-container-cli mount error, libnvidia-ml.so.1: file exists: unknown</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ApolloAuto/apollo/issues/15246">Apollo Github Issue-15246 dev_start进不去
</a></li>
</ol>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>首先根据官方文档安装好依赖，然后下载<code>Apollo v9.0.0</code>源码，解压后进入<code>apollo</code>目录。</p>
<h3 id="1-修改dev-start-sh脚本"><a href="#1-修改dev-start-sh脚本" class="headerlink" title="1. 修改dev_start.sh脚本"></a>1. 修改<code>dev_start.sh</code>脚本</h3><p>Apollo默认镜像对于40系列显卡不支持，根据参考资料2，需要修改<code>docker/scripts/dev_start.sh</code>中的<code>VERSION_X86_64</code>镜像版本:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERSION_X86_64=&quot;dev-x86_64-18.04-20231128_2222&quot;</span><br></pre></td></tr></table></figure>
<p>按照参考资料2中的步骤说明，下一步直接执行<code>./docker/scripts/dev_start.sh</code>进行镜像构建即可，但在<code>WSL2</code>下构建会出现以下问题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-container-cli mount error, libnvidia-ml.so.1: file exists: unknown.</span><br></pre></td></tr></table></figure>
<p>实际上镜像已经成功生成，只是在执行容器时出现错误，根据参考资料5和参考资料6，首先将<code>dev_start.sh</code>中的容器执行命令注释掉。</p>
<p>然后按照以下步骤进行操作：</p>
<p>```bash</p>
<h1 id="查看docker-镜像id"><a href="#查看docker-镜像id" class="headerlink" title="查看docker 镜像id"></a>查看docker 镜像id</h1><p>docker images</p>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>sudo docker run -it —rm <Apollo的镜像ID></p>
<h1 id="删除镜像内NVIDIA相关文件"><a href="#删除镜像内NVIDIA相关文件" class="headerlink" title="删除镜像内NVIDIA相关文件"></a>删除镜像内NVIDIA相关文件</h1><p>rm /usr/lib/x86_64-linux-gnu/libnvidia-<em><br>rm /usr/lib/x86_64-linux-gnu/libcuda.so</em><br>rm /usr/lib/x86_64-linux-gnu/libnvcuvid.so.*</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/04/09/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2-VsCode-ROS-Docker%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/09/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2-VsCode-ROS-Docker%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">WSL2-VsCode-ROS-Docker项目开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-09 22:05:11" itemprop="dateCreated datePublished" datetime="2024-04-09T22:05:11+08:00">2024-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 Windows 系统上使用 WSL2 + VS Code + ROS + Docker 进行项目开发。</p>
<p>WSL2 + VS Code是此前一直使用的开发方式，只要使用VS Code的WSL插件，就可以在WSL2中进行开发，而不用在Windows系统中安装编译器和调试器。在一般的C++项目开发中，运行调试项目可以通过设置<code>.vscode/launch.jso</code>n，<code>.vscode/tasks.json</code>，<code>.vscode/c_cpp_properties.json</code>等文件来实现。但是在开发ROS项目时，需要在VSC中安装ROS插件，这样才能在VSC中运行ROS项目。并且使用ROS插件提供的设置来运行ROS项目。这个插件有一些bug，有时会出现一些奇怪的问题。另外，在运行<code>ros_motion_planning</code>项目时，在<code>ubuntu-18.04</code>下始终无法编译通过，而在<code>ubuntu-20.04</code>下运行还需要设置很多东西，恰巧该项目提供了<code>dockerfile</code>，因此使用 WSL2 + VS Code + ROS + Docker 进行项目开发。这里对于遇到的问题及解决方案进行记录。有一些具有很多教程的步骤，在这里不再赘述。比如安装WSL2，安装VS Code，安装ROS，Windows下安装docker并使用WSL2作为后端引擎等。</p>
<h2 id="docker的基本命令"><a href="#docker的基本命令" class="headerlink" title="docker的基本命令"></a>docker的基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 查看所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f &lt;container_id&gt;</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image_id&gt;</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container_id&gt; /bin/bash</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t &lt;image_name&gt; .</span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -it --name &lt;container_name&gt; &lt;image_name&gt; /bin/bash</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image prune</span><br><span class="line"><span class="comment"># 删除不再使用的数据卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="comment"># 删除build cache</span></span><br><span class="line">docker builder prune</span><br><span class="line"><span class="comment"># 删除所有未使用的资源</span></span><br><span class="line">docker system prune</span><br><span class="line"><span class="comment"># 查看docker占用空间</span></span><br><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<h2 id="项目docker镜像构建"><a href="#项目docker镜像构建" class="headerlink" title="项目docker镜像构建"></a>项目docker镜像构建</h2><p>ros_motion_planning的项目结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ros_motion_planning</span><br><span class="line">$ tree -d -L 3</span><br><span class="line">.</span><br><span class="line">├── assets</span><br><span class="line">├── data</span><br><span class="line">├── docker</span><br><span class="line">│   └── noetic</span><br><span class="line">├── docs</span><br><span class="line">├── package</span><br><span class="line">│   ├── osqp</span><br><span class="line">│   │   ├── configure</span><br><span class="line">│   │   ├── docs</span><br><span class="line">│   │   ├── examples</span><br><span class="line">│   │   ├── include</span><br><span class="line">│   │   ├── lin_sys</span><br><span class="line">│   │   ├── site</span><br><span class="line">│   │   ├── src</span><br><span class="line">│   │   └── tests</span><br><span class="line">│   └── osqp-eigen</span><br><span class="line">│       ├── cmake</span><br><span class="line">│       ├── docs</span><br><span class="line">│       ├── example</span><br><span class="line">│       ├── include</span><br><span class="line">│       ├── src</span><br><span class="line">│       └── tests</span><br><span class="line">├── scripts</span><br><span class="line">└── src</span><br><span class="line">    ├── core</span><br><span class="line">    │   ├── curve_generation</span><br><span class="line">    │   ├── global_planner</span><br><span class="line">    │   ├── local_planner</span><br><span class="line">    │   ├── trajectory_optimization</span><br><span class="line">    │   └── utils</span><br><span class="line">    ├── sim_env</span><br><span class="line">    │   ├── config</span><br><span class="line">    │   ├── launch</span><br><span class="line">    │   ├── maps</span><br><span class="line">    │   ├── meshes</span><br><span class="line">    │   ├── models</span><br><span class="line">    │   ├── rviz</span><br><span class="line">    │   ├── scripts</span><br><span class="line">    │   ├── urdf</span><br><span class="line">    │   └── worlds</span><br><span class="line">    ├── third_party</span><br><span class="line">    │   ├── dynamic_rviz_config</span><br><span class="line">    │   ├── dynamic_xml_config</span><br><span class="line">    │   ├── gazebo_plugins</span><br><span class="line">    │   ├── map_plugins</span><br><span class="line">    │   └── rviz_plugins</span><br><span class="line">    └── user_config</span><br></pre></td></tr></table></figure>
<p>项目提供的dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use the official ROS Noetic base image</span></span><br><span class="line"><span class="keyword">FROM</span> osrf/ros:noetic-desktop-full</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install additional dependencies if needed</span></span><br><span class="line"><span class="comment"># psmisc(用于进程查看)，libxml2、libxslt(用于 XML/XSLT 处理)，python-is-python3(将 python3 设置为默认 python 版本)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get -y --no-install-recommends install \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    gcc \</span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    psmisc \</span></span><br><span class="line"><span class="language-bash">    libxml2-dev \</span></span><br><span class="line"><span class="language-bash">    libxslt-dev \</span></span><br><span class="line"><span class="language-bash">    python3 \</span></span><br><span class="line"><span class="language-bash">    python3-pip \ </span></span><br><span class="line">    python-is-python3\</span><br><span class="line">    ros-noetic-amcl \</span><br><span class="line">    ros-noetic-base-local-planner \</span><br><span class="line">    ros-noetic-map-server \</span><br><span class="line">    ros-noetic-move-base \</span><br><span class="line">    ros-noetic-navfn</span><br><span class="line"></span><br><span class="line"><span class="comment"># python packages</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install setuptools &amp;&amp; pip3 install catkin-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the project into the container</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># catkin build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;. /opt/ros/noetic/setup.bash; catkin_make&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>在执行软件更新及安装时，由于网络问题，可能会更新较慢或者失败，可以在dockerfile中添加中科大的源，如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure>
<p>具体来说:</p>
<ul>
<li><code>sed</code> 是一个流编辑器,常用于文本替换操作。</li>
<li><code>-i</code> 选项指示 <code>sed</code> 直接修改文件内容,而不是输出到标准输出。</li>
<li>‘s/archive.ubuntu.com/mirrors.ustc.edu.cn/g’ 是一个替换命令,其中: <code>s</code> 是替换命令。<code>archive.ubuntu.com</code> 是要被替换的原始字符串。<code>mirrors.ustc.edu.cn</code> 是要替换成的新字符串。<code>g</code> 表示在整个文件中进行全局替换,而不仅仅是替换第一次出现的地方。</li>
</ul>
<p>总结来说，以上命令可将 <code>/etc/apt/sources.list</code> 文件中所有出现的 <code>archive.ubuntu.com</code> 都替换为 <code>mirrors.ustc.edu.cn</code>。</p>
<p>增加了中科大源后，构建镜像时，速度会快很多，镜像构建的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> docker/noetic</span><br><span class="line">docker build -t ros-motion-planning:noetic --no-cache -f ./Dockerfile ../../</span><br></pre></td></tr></table></figure>
<p>构建在进行到最后一步的<code>catkin_make</code>时，出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">9.440 CMake Error at core/local_planner/mpc_planner/CMakeLists.txt:19 (find_package):</span><br><span class="line">9.440   By not providing <span class="string">&quot;FindOsqpEigen.cmake&quot;</span> <span class="keyword">in</span> CMAKE_MODULE_PATH this project</span><br><span class="line">9.440   has asked CMake to find a package configuration file provided by</span><br><span class="line">9.440   <span class="string">&quot;OsqpEigen&quot;</span>, but CMake did not find one.</span><br><span class="line">9.440 </span><br><span class="line">9.440   Could not find a package configuration file provided by <span class="string">&quot;OsqpEigen&quot;</span> with</span><br><span class="line">9.440   any of the following names:</span><br><span class="line">9.440 </span><br><span class="line">9.440     OsqpEigenConfig.cmake</span><br><span class="line">9.440     osqpeigen-config.cmake</span><br><span class="line">9.440 </span><br><span class="line">9.440   Add the installation prefix of <span class="string">&quot;OsqpEigen&quot;</span> to CMAKE_PREFIX_PATH or <span class="built_in">set</span></span><br><span class="line">9.440   <span class="string">&quot;OsqpEigen_DIR&quot;</span> to a directory containing one of the above files.  If</span><br><span class="line">9.440   <span class="string">&quot;OsqpEigen&quot;</span> provides a separate development package or SDK, be sure it has</span><br><span class="line">9.440   been installed.</span><br><span class="line">9.440 </span><br><span class="line">9.440 </span><br><span class="line">9.448 -- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure>
<p>显然是由于缺少<code>OsqpEigen</code>库导致的错误，查看项目的<code>README.md</code>文件，可看到以下关于<code>OSQP</code>和<code>OsqpEigen</code>安装的部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OSQP</span></span><br><span class="line">git <span class="built_in">clone</span> -b release-0.6.3 --recursive https://github.com/oxfordcontrol/osqp</span><br><span class="line"><span class="built_in">cd</span> osqp &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON</span><br><span class="line">make -j6</span><br><span class="line">sudo make install</span><br><span class="line">sudo <span class="built_in">cp</span> /usr/local/include/osqp/* /usr/local/include</span><br><span class="line"></span><br><span class="line"><span class="comment"># OsqpEigen</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/robotology/osqp-eigen.git</span><br><span class="line"><span class="built_in">cd</span> osqp-eigen &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>所以可以参考以上内容，在构建时增加<code>OSQP</code>和<code>OsqpEigen</code>的安装，首先新建一个<code>package</code>目录用于存放<code>OSQP</code>和<code>OsqpEigen</code>的源文件，然后在<code>scripts</code>目录下新建一个<code>install_osqp.sh</code>文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install osqp</span></span><br><span class="line"><span class="built_in">cd</span> /project/package/osqp</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean up</span></span><br><span class="line"><span class="built_in">cd</span> /project/package/osqp</span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install osqp-eigen</span></span><br><span class="line"><span class="built_in">cd</span> /project/package/osqp-eigen</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean up</span></span><br><span class="line"><span class="built_in">cd</span> /project/package/osqp-eigen</span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br></pre></td></tr></table></figure>
<p>在<code>dockerfile</code>中增加以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install osqp and osqp-eigen</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /project/scripts/install_osqp.sh</span></span><br></pre></td></tr></table></figure>
<p>出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=&gt; ERROR [ 9/10] RUN /project/scripts/install_osqp.sh 0.5s</span><br><span class="line">------</span><br><span class="line">&gt; [ 9/10] RUN /project/scripts/install_osqp.sh:</span><br><span class="line">0.471 /project/scripts/install_osqp.sh: line 5: <span class="built_in">cd</span>: /project/package/osqp: No such file or directory</span><br><span class="line">------</span><br></pre></td></tr></table></figure>
<p>仔细排查后，发现这是由于项目的<code>.dockerignore</code>文件导致的，.dockerignore 文件用于排除不需要复制到 Docker 镜像中的文件和目录, 该项目的<code>.dockerignore</code>文件如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"></span><br><span class="line">!assets</span><br><span class="line">!docker</span><br><span class="line">!docs</span><br><span class="line">!package</span><br><span class="line">!scripts</span><br><span class="line">!src</span><br><span class="line">!Doxyfile</span><br><span class="line">!LICENSE</span><br><span class="line">!README.md</span><br><span class="line">!.clang-format</span><br></pre></td></tr></table></figure>
<p>其中<code>*</code>表示排除所有文件和目录，<code>!</code>表示不排除，所以需要在<code>.dockerignore</code>文件中添加<code>!package</code>，然后重新构建镜像，此时出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">27.27 Scanning dependencies of target mpc_planner</span><br><span class="line">27.30 [89%] Building CXX object core/local_planner/mpc_planner/CMakeFiles/mpc_planner.dir/src/mpc_planner.cpp.o</span><br><span class="line">27.52 In file included from /usr/local/include/OsqpEigen/Compat.hpp:12,</span><br><span class="line">27.52 from /usr/local/include/OsqpEigen/Constants.hpp:11,</span><br><span class="line">27.52 from /usr/local/include/OsqpEigen/OsqpEigen.h:10,</span><br><span class="line">27.52 from /project/src/core/local_planner/mpc_planner/src/mpc_planner.cpp:19:</span><br><span class="line">27.52 /usr/local/include/osqp.h:9:11: fatal error: types.h: No such file or directory</span><br><span class="line">27.52 9 | <span class="comment"># include &quot;types.h&quot;</span></span><br><span class="line">27.52 | ^~~~~~~~~</span><br><span class="line">27.52 compilation terminated.</span><br><span class="line">27.52 make[2]: *** [core/local_planner/mpc_planner/CMakeFiles/mpc_planner.dir/build.make:63: core/local_planner/mpc_planner/CMakeFiles/mpc_planner.dir/src/mpc_planner.cpp.o] Error 1</span><br><span class="line">27.52 make[1]: *** [CMakeFiles/Makefile2:8368: core/local_planner/mpc_planner/CMakeFiles/mpc_planner.dir/all] Error 2</span><br><span class="line">27.52 make[1]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br></pre></td></tr></table></figure>
<p>尝试将<code>OSQP</code>和<code>OsqpEigen</code>的源文件复制到<code>/usr/local/include</code>目录下，但是似乎没有作用，因此放弃了这种方式，而是直接在<code>dockerfile</code>中将<code>OSQP</code>的include路径添加到了环境变量中，此后构建成功，完整的修改后的<code>dockerfile</code>如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use the official ROS Noetic base image</span></span><br><span class="line"><span class="keyword">FROM</span> osrf/ros:noetic-desktop-full</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># Install additional dependencies if needed</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get -y --no-install-recommends install \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    gcc \</span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    psmisc \</span></span><br><span class="line"><span class="language-bash">    libxml2-dev \</span></span><br><span class="line"><span class="language-bash">    libxslt-dev \</span></span><br><span class="line"><span class="language-bash">    python3 \</span></span><br><span class="line"><span class="language-bash">    python3-pip \ </span></span><br><span class="line">    python-is-python3\</span><br><span class="line">    ros-noetic-amcl \</span><br><span class="line">    ros-noetic-base-local-planner \</span><br><span class="line">    ros-noetic-map-server \</span><br><span class="line">    ros-noetic-move-base \</span><br><span class="line">    ros-noetic-navfn</span><br><span class="line"></span><br><span class="line"><span class="comment"># python packages</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install setuptools &amp;&amp; pip3 install catkin-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the project into the container</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install osqp and osqposqp-eigen</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /project/scripts/install_osqp.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> CPLUS_INCLUDE_PATH=<span class="string">&quot;$&#123;CPLUS_INCLUDE_PATH&#125;:/project/package/osqp/include&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># catkin build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;. /opt/ros/noetic/setup.bash; catkin_make;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ROS-项目调试"><a href="#ROS-项目调试" class="headerlink" title="ROS 项目调试"></a>ROS 项目调试</h2><p>项目构建成功后，可使用以下命令运行容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> --<span class="built_in">env</span>=<span class="string">&quot;QT_X11_NO_MITSHM=1&quot;</span> --volume=<span class="string">&quot;/tmp/.X11-unix:/tmp/.X11-unix:rw&quot;</span> --name=ros-motion-planning-noetic ros-motion-planning:noetic /bin/bash</span><br></pre></td></tr></table></figure>
<p>利用vscode的插件<code>Remote Development</code>、<code>Docker</code>、<code>ROS</code>、<code>Remote Explorer</code>等插件，可以在vscode中直接连接到docker容器中，然后在vscode中打开项目文件夹，即可在vscode中进行ros项目开发调试。出于个人习惯，使用clang提供代码补全，可参见<a href="https://slam-learner.github.io/2024/04/01/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/clang/">这个博客</a>进行设置。</p>
<p>创建<code>.vscode</code>文件夹，然后在其中创建<code>launch.json</code>、<code>tasks.json</code>、<code>c_cpp_properties.json</code>等文件。</p>
<p><code>c_cpp_properties.json</code>文件如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/include/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;configurationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-vscode.cmake-tools&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>tasks.json</code>文件如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build_debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;cd build_debug &amp;&amp; cmake -DCMAKE_BUILD_TYPE=DEBUG .. &amp;&amp; make -j4&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;focus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>launch.json</code>文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ROS: launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/project/src/sim_env/launch/main.launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make_debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>点击运行，出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error from roslaunch:</span><br><span class="line">xacro: in-order processing became default <span class="keyword">in</span> ROs Melodic. You can drop the option.</span><br></pre></td></tr></table></figure>
<p>按下<code>ctrl+shift+f</code>搜索<code>--inorder</code>，将其删除，再次运行，可以解决此问题，但是又出现了以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unable to start debugging.Launch options string provided by the project system is</span><br><span class="line">invalid.Unable to determine path to debugger.Please specify the</span><br><span class="line"><span class="string">&quot;MIDebuggerPath&quot;</span>option.</span><br></pre></td></tr></table></figure>
<p>根据ROS插件的一个<a target="_blank" rel="noopener" href="https://github.com/ms-iot/vscode-ros/issues/588">GitHub Issue</a>，这是由于ROS插件基于<code>gdb</code>进行调试，而此镜像没有安装<code>gdb</code>，使用<code>apt-get install gdb</code>安装<code>gdb</code>，再次运行，可以解决此问题，此时出现以下错误提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROS launch can not load launch file that includes gazebo (program path <span class="string">&#x27;PATH&#x27;</span> is missing or invalid</span><br></pre></td></tr></table></figure>
<p>根据<a target="_blank" rel="noopener" href="https://github.com/ms-iot/vscode-ros/issues/474">issue-474</a>以及插件的官方说明，插件无法调试<code>gazebo</code>，因此需要在<code>launch.json</code>文件中将<code>gazebo</code>相关的<code>launch</code>文件注释掉，再次运行，可以正常启动<code>ros</code>项目。<br><img src="https://raw.githubusercontent.com/slam-learner/Figures/main/PicGo/20240410111451.png" alt="20240410111451"><br>根据插件中的说明，修改<code>launch.json</code>屏蔽<code>gazebo</code>等插件，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ROS: launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ros&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/project/src/sim_env/launch/main.launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;launch&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;rviz&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gz&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gzserver&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gzclient&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make_debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在配置完全部环境之后，可以将配置好的环境重新打包成镜像，以便下次使用，具体的步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. check the container id</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 2. commit the container</span></span><br><span class="line">docker commit &lt;container_id&gt; ros-motion-planning:vscode-ros-dev</span><br><span class="line"><span class="comment"># 3. save the image</span></span><br><span class="line">docker save -o ros-motion-planning-vscode-ros-dev.tar ros-motion-planning:vscode-ros-dev</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/04/01/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/clang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/clang/" class="post-title-link" itemprop="url">clang</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 13:40:07" itemprop="dateCreated datePublished" datetime="2024-04-01T13:40:07+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/551978555">参考资料 1</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/445300679">参考资料 2</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>如果想要了解clang 首先要明白 LSP（Language Server Protocol）：语言服务协议。</p>
<p>传统的 IDE，即使离线使用时也能完成语法检查、自动补全、跳转位置、引用、查找等功能。因为这些 IDE 的语法特性检查功能都是在本地实现的。不仅如此，各家 IDE 都有各家的实现。比如以 Java IDE 为例，对于 Java 的语法特性检查，IntelliJ IDEA 有其自己的实现方式，Eclipse 也有其自己的实现方式。这就造成了对于同一种编程语言的语法解析需要针对不同的 IDE 进行不同的适配。其次，语言扫描相关的工作都比较占用 CPU 资源，运行在 vscode 进程中不如单独放在一个独立进程，甚至远程服务器上更好。</p>
<p>由于各种新技术新语言层出不穷，VSCode 开发人员不可能对任何一种编程语言的语法都了如指掌，专业领域的编程语言的语法解析，由编程语言的开发者来实现是最好的。</p>
<p>LSP(Language Server Protocol) 语言服务协议，此协议定义了在编辑器与语言服务器之间使用的协议。</p>
<p>通过LSP使得编程语言社区能专注于不断完善一个能提供语法检查、自动补全、跳转位置、引用查找等语言特性检查的高性能 “语言服务器” 实现。与此同时，IDE厂商和组织只专注于提供能与任何 “语言服务器” 交互和 “渲染” 响应的实现方案。</p>
<h3 id="LLVM-与-Clang"><a href="#LLVM-与-Clang" class="headerlink" title="LLVM 与 Clang"></a>LLVM 与 Clang</h3><p>简单来说，LLVM 是编译器后端，Clang 是编译器前端。</p>
<h4 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h4><p>LLVM（Low Level Virtual Machine）。LLVM 是以 BSD 许可来开发的开源的编译器框架系统，基于 C++ 编写而成，利用虚拟技术来优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，最早以 C/C++ 为实现对象，对开发者保持开放，并兼容已有脚本。</p>
<p>目前 LLVM 因其宽松的许可协议，更好的模块化、更清晰的架构，成为很多厂商或者组织的选择，已经被苹果 IOS 开发工具、Facebook、Google 等各大公司采用，像 Swift、Rust 等语言都选择了以 LLVM 为后端。</p>
<p>大多数编译器由两部分组成：前端和后端。</p>
<ul>
<li>前端负责语法分析，生成中间代码；</li>
<li>后端以中间代码作为输入，进行架构无关的代码优化，接着针对不同架构生成不同的机器码。</li>
</ul>
<p>这种架构使得前后端依赖统一格式的中间代码(IR)，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个CPU架构只需要修改后端即可。</p>
<p>  Objective C/C/C++使用的编译器前端是Clang，Swift使用的是Swift，后端都是LLVM。</p>
<h4 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h4><p>在 LibTooling 的基础之上有个开发人员工具合集Clang tools。Clang Tools是为 C++ 开发人员设计的独立命令行（可能还有GUI）工具。目前只有几个最基础和最根本的的工具保存在主 Clang目录树中，其余的工具保存在一个单独的目录树中称为Extra Clang Tools；</p>
<p>Clang的Extra Clang Tools中有一个工具是<strong>Clangd</strong>。它是对LSP协议的一个具体实现（当然是建立在Clang的基础之上的），目的是为了<strong>给C/C++的编辑器提供编程语言的一些智能化的特性</strong>，比如代码分析、引用查找等。</p>
<p>  <strong>LLDB</strong>（Low-Level Debugger）则是一种开源的<strong>调试器</strong>，最初是作为 LLVM 项目的一部分而开发的。它设计用于支持多种编程语言，包括 C, C++, Objective-C, 和 Swift。</p>
<h2 id="Clang-的安装"><a href="#Clang-的安装" class="headerlink" title="Clang 的安装"></a>Clang 的安装</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_34986308/article/details/116116780">参考博客</a><br>在 Ubuntu18.04 中安装 Clang-12 以上版本的话需要新增软件源，按照以下步骤进行：</p>
<p>1.获取key</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>2.在 <code>/etc/apt/sources.list</code> 中添加下列文本:（如果不是18.04，需要把bionic替换为对应的版本，可以通过 <code>lsb_release -a</code> 查看）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main</span><br><span class="line">deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main</span><br><span class="line"># 11</span><br><span class="line">deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main</span><br><span class="line">deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-11 main</span><br><span class="line"># 12</span><br><span class="line">deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-12 main</span><br><span class="line">deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-12 main</span><br></pre></td></tr></table></figure>
<p>3.安装相关软件包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install clang-12 clangd-12 llvm-12 llvm-12-dev liblldb-12 liblldb-12-dev clang-format-12 bear clang-tidy-12</span><br></pre></td></tr></table></figure>
<p>4.使用 update-alternative 来设置设置默认命令使用 12 版本提供的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/lldb lldb /usr/bin/lldb-12 100</span><br></pre></td></tr></table></figure>
<h3 id="在-Vs-Code-中的配置"><a href="#在-Vs-Code-中的配置" class="headerlink" title="在 Vs Code 中的配置"></a>在 Vs Code 中的配置</h3><p>必装： 1. clangd 2. CodeLLDB</p>
<p>选装： 3. CMake 4. CMake Tools 5. Clang-Format 6.  Code Runner</p>
<h4 id="在用户-json-中的配置"><a href="#在用户-json-中的配置" class="headerlink" title="在用户 json 中的配置"></a>在用户 json 中的配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// code runner</span></span><br><span class="line">    <span class="attr">&quot;code-runner.runInTerminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.saveFileBeforeRun&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// run code前保存</span></span><br><span class="line">    <span class="attr">&quot;code-runner.clearPreviousOutput&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 每次run code前清空属于code runner的终端消息，默认false</span></span><br><span class="line">    <span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--compile-commands-dir=$&#123;workspaceFolder&#125;/build&quot;</span><span class="punctuation">,</span><span class="comment">//指定配置文件compelie_commands.json所在目录，这里有三种方法生成</span></span><br><span class="line">        <span class="comment">// 在后台自动分析文件（基于complie_commands)</span></span><br><span class="line">        <span class="string">&quot;--background-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 同时开启的任务数量</span></span><br><span class="line">        <span class="string">&quot;-j=12&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// &quot;--folding-ranges&quot;</span></span><br><span class="line">        <span class="comment">// 告诉clangd用那个clang进行编译，路径参考which clang++的路径</span></span><br><span class="line">        <span class="string">&quot;--query-driver=/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// clang-tidy功能</span></span><br><span class="line">        <span class="string">&quot;--clang-tidy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--clang-tidy-checks=performance-*,bugprone-*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 全局补全（会自动补充头文件）</span></span><br><span class="line">        <span class="string">&quot;--all-scopes-completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 更详细的补全内容</span></span><br><span class="line">        <span class="string">&quot;--completion-style=detailed&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--function-arg-placeholders&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 补充头文件的形式</span></span><br><span class="line">        <span class="string">&quot;--header-insertion=iwyu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// pch优化的位置</span></span><br><span class="line">        <span class="string">&quot;--pch-storage=memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>生成 clangd 配置文件</p>
<p>1.在 CMakeLists.txt 文件中添加 set(CMAKE_EXPORT_COMPILECOMMANDS ON) 运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake ..</span><br></pre></td></tr></table></figure>
<p>可以发现在 build目录下已经生成了 compile_commands.json文件</p>
<p>2.make 或其他项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br><span class="line">bear make</span><br></pre></td></tr></table></figure>
<h4 id="launch-json"><a href="#launch-json" class="headerlink" title="launch. json"></a>launch. json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DomiMonoDebug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/your-exe-path&quot;</span><span class="punctuation">,</span> <span class="comment">// 可执行文件路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;arg1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;arg2&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 命令行参数</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build_debug&quot;</span> <span class="comment">// 预构建任务名称</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks. json"></a>tasks. json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build_debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;cd build_debug &amp;&amp; cmake -DCMAKE_BUILD_TYPE=DEBUG .. &amp;&amp; make -j4&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;focus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties. json"></a>c_cpp_properties. json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/include/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/compile_commands.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;configurationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-vscode.cmake-tools&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>有一篇<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/579294471">知乎文章</a> 中提到：</p>
<blockquote>
<p>lldb 不自带 lldb-mi，但在 VSCode 进行调试时需要，所以要自己生成一下</p>
</blockquote>
<p>需要进行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install liblldb-dev</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lldb-tools/lldb-mi.git</span><br><span class="line"><span class="built_in">cd</span> lldb-mi</span><br><span class="line">cmake .</span><br><span class="line">cmake --build .</span><br><span class="line">sudo <span class="built_in">cp</span> src/lldb-mi /usr/bin/</span><br></pre></td></tr></table></figure>
<p>其中编译会报错，按照提示，找到报错位置，注释掉相应的代码即可，但是可能不需要这个步骤也可以成功完成调试。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%81%E7%A7%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%81%E7%A7%BB/" class="post-title-link" itemprop="url">WSL备份与迁移</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-27 13:40:07" itemprop="dateCreated datePublished" datetime="2024-03-27T13:40:07+08:00">2024-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>538</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>终止正在运行的 wsl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
<p>ubuntu 名字用 wsl -l -v 查看，这里以导出到 G 盘下，命名为 Ubuntu_bak.tar 为例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="keyword">export</span> ubuntu-<span class="number">22.04</span> <span class="attr">G</span>:\<span class="title class_">Ubuntu</span>_bak.<span class="property">tar</span></span><br></pre></td></tr></table></figure>
<h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p>注销之前的 wsl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister ubuntu-22.04</span><br></pre></td></tr></table></figure>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import ubuntu-22.04 G:\WSL_Ubuntu G:\Ubuntu_bak.tar --version 2</span><br></pre></td></tr></table></figure>
<h2 id="升级-wsl-版本"><a href="#升级-wsl-版本" class="headerlink" title="升级 wsl 版本"></a>升级 wsl 版本</h2><p>如果之前的 wsl 版本为 wsl1，需要升级到 wsl2 的话，需要执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version ubuntu-22.04 2</span><br></pre></td></tr></table></figure>
<p>如果 powershell 中提示需要升级，那么需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>
<p>设置默认 wsl 默认版本为 wsl2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<p>查看安装版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p><strong>参数解读：</strong><br><em>Ubuntu-22.04</em><br>· 实例名称，可以自己设置，设置后即为第 2 步输入 wsl -l -v 后显示的名称；<br><em>G:\WSL_Ubuntu</em><br>· 导入后的镜像及其相关数据存放路径；<br><em>G:\wsl_nomatlab. Tar</em><br>· 导入的备份，即第 3 步通过 wsl —export 导出的文件；<br><em>–version 2</em><br>· WSL 版本为2</p>
<p><strong>用户设置</strong><br>方法 1： 管理员身份运行 power shell, 执行 <code>ubuntu2004.exe config --default-user root</code> ,再在 power shell，执行以下命令，可以将 WSL2的默认系统设置为 Ubuntu-20.04。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault Ubuntu-20.04</span><br></pre></td></tr></table></figure>
<p>方法 2：修改 <code>/etc/wsl.conf</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Set the user when launching a distribution with WSL.</span></span><br><span class="line"></span><br><span class="line">[user]</span><br><span class="line">default=username</span><br></pre></td></tr></table></figure>
<p>方法 3：在 windows terminal 中按下三角按钮打开设置, 并在命令行设置中进行修改， -d 参数修改发行版本，-u 修改用户。<br><img src="https://raw.githubusercontent.com/slam-learner/Figures/main/PicGo/202403271350893.png" alt="Windows Terminal设置"></p>
<h2 id="压缩空间"><a href="#压缩空间" class="headerlink" title="压缩空间"></a>压缩空间</h2><p><code>WSL2</code> 本质上是虚拟机，所以 <code>Windows</code> 会自动创建 <code>vhdx</code> 后缀的虚拟磁盘文件作为存储。这个 <code>vhdx</code> 后缀的虚拟磁盘文件特点是可以自动扩容，但是一般不会自动缩容。一旦有很多文件把它“撑大”，即使把这些文件删除它也不会自动“缩小”。所以删除文件后还需要我们手动进行压缩才能释放磁盘空间。</p>
<p>首先在 PowerShell 中执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭 wsl</span></span><br><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行管理计算机驱动器的 DiskPart命令</span></span><br><span class="line">diskpart</span><br></pre></td></tr></table></figure>
<p>在新打开的 <code>DiskPart</code> 命令窗口中执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择虚拟磁盘文件</span></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;D:\WSL\Ubuntu-18.04\ext4.vhdx&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">compact vdisk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩完毕后卸载磁盘（可能会有报错/警告，正常现象）</span></span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure>
<h2 id="需要开启或安装的功能-包"><a href="#需要开启或安装的功能-包" class="headerlink" title="需要开启或安装的功能/包"></a>需要开启或安装的功能/包</h2><p>直接按 win 键搜索 “启用或关闭 Windows 功能”即可找到选项卡，开启以下功能（不开启也可以正常使用，不清楚具体影响）。</p>
<p><img src="https://raw.githubusercontent.com/slam-learner/Figures/main/PicGo/![[启用或关闭Windows功能选项卡.png]].png" alt="![[启用或关闭Windows功能选项卡.png]]"><br>商店中安装 Ubuntu 18.04 LTS</p>
<p><img src="https://raw.githubusercontent.com/slam-learner/Figures/main/PicGo/![[18.04LTS商店安装.png]].png" alt="![[18.04LTS商店安装.png]]"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aeef20207355">修改默认登陆用户</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/poena/article/details/106451847">WSL 使用与迁移</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60634555/article/details/129699609">wsl 版本升级</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E9%95%9C%E5%83%8F%E6%BA%90%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E9%95%9C%E5%83%8F%E6%BA%90%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">镜像源设置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-27 13:36:07" itemprop="dateCreated datePublished" datetime="2024-03-27T13:36:07+08:00">2024-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>91</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="手动替换"><a href="#手动替换" class="headerlink" title="手动替换"></a>手动替换</h3><p><strong>原始：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/aaa/bbb.git</span><br></pre></td></tr></table></figure>
<p><strong>替换后：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitclone.com/github.com/aaa/bbb.git</span><br></pre></td></tr></table></figure>
<h3 id="使用命令进行全局替换"><a href="#使用命令进行全局替换" class="headerlink" title="使用命令进行全局替换"></a>使用命令进行全局替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;https://gitclone.com/&quot;</span>.insteadOf https://</span><br></pre></td></tr></table></figure>
<p>全局参数更改之后，可以使用 <code>vim ~/.gitconfig</code> 命令查看当前的配置文件，可以看到以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;https://url you choose&quot;] </span><br><span class="line">        insteadOf = https://github.com/</span><br></pre></td></tr></table></figure>
<p>对 url 内部的内容进行替换可以更换镜像源，以下是可能可以用的镜像源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://github.com.cnpmjs.org</span><br><span class="line"># 服务器位于香港</span><br><span class="line"></span><br><span class="line">https://gitclone.com</span><br><span class="line"># 服务器位于杭州</span><br><span class="line"></span><br><span class="line">https://doc.fastgit.org</span><br><span class="line"># 服务器位于香港</span><br></pre></td></tr></table></figure>
<p>一般使用 <code>https://gitclone.com</code> 即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Updatedb%E6%8E%92%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Updatedb%E6%8E%92%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9/" class="post-title-link" itemprop="url">Updatedb排除文件夹</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-22 21:03:07" itemprop="dateCreated datePublished" datetime="2024-03-22T21:03:07+08:00">2024-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>/etc/updatedb.conf</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRUNE_BIND_MOUNTS=&quot;yes&quot;</span><br><span class="line"># PRUNENAMES=&quot;.git .bzr .hg .svn&quot;</span><br><span class="line">PRUNEPATHS=&quot;/tmp /var/spool /media /var/lib/os-prober /var/lib/ceph /home/.ecryptfs /var/lib/schroot /mnt/c /mnt/d&quot;</span><br><span class="line">PRUNEFS=&quot;NFS nfs nfs4 rpc_pipefs afs binfmt_misc proc smbfs autofs iso9660 ncpfs coda devpts ftpfs devfs devtmpfs fuse.mfs shfs sysfs cifs lustre tmpfs usbfs udf fuse.glusterfs fuse.sshfs curlftpfs ceph fuse.ceph fuse.rozofs ecryptfs fusesmb&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/19/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%84%9A%E6%9C%AC%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/19/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%84%9A%E6%9C%AC%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8/" class="post-title-link" itemprop="url">脚本桌面快捷启动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-19 14:43:47" itemprop="dateCreated datePublished" datetime="2024-03-19T14:43:47+08:00">2024-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">环境配置</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>225</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个较大的ros项目中，完整的启动所有节点，需要使用多个终端窗口分别启动不同的节点。这样的操作非常繁琐，所以编写了一个脚本启动所有的节点并在Ubuntu的桌面上创建了一个快捷方式点击即可运行。</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## author: ydx</span></span><br><span class="line"><span class="comment">## description: 运行项目</span></span><br><span class="line"><span class="comment">## date: 2024-03-15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印用法说明</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: run_sim.sh [USE_BAG_FILE] [START_TYPE]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  USE_BAG_FILE: 是否使用bag文件, true or false, 默认为true&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  START_TYPE: 启动类型, 0: 使用bash终端运行, 1: 使用xterm, 2: 使用gnome-terminal, 默认为1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认参数</span></span><br><span class="line">USE_BAG_FILE=<span class="string">&quot;<span class="variable">$&#123;1:-true&#125;</span>&quot;</span></span><br><span class="line">START_TYPE=<span class="string">&quot;<span class="variable">$&#123;2:-1&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取项目目录</span></span><br><span class="line">PROJ_DIR=<span class="string">&quot;<span class="subst">$(realpath $(dirname <span class="string">&quot;<span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span>)</span>/..)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要使用bag文件, 则播放bag文件</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$USE_BAG_FILE</span>&quot;</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 启动 roscore</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Starting roscore...&quot;</span></span><br><span class="line">    roscore &amp;</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Playing rosbag...&quot;</span></span><br><span class="line">    rosbag play <span class="string">&quot;<span class="variable">$PROJ_DIR</span>/data/lidar_imu_2024-03-13.bag&quot;</span> &amp;</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动节点函数</span></span><br><span class="line"><span class="function"><span class="title">start_node</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> package=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> launch_file=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$START_TYPE</span> <span class="keyword">in</span></span><br><span class="line">        0)</span><br><span class="line">            <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$PROJ_DIR</span>/devel/setup.bash&quot;</span>; roslaunch <span class="string">&quot;<span class="variable">$package</span>&quot;</span> <span class="string">&quot;<span class="variable">$launch_file</span>&quot;</span> &amp;</span><br><span class="line">            ;;</span><br><span class="line">        1)</span><br><span class="line">            xterm -e <span class="string">&quot;source <span class="variable">$PROJ_DIR</span>/devel/setup.bash; roslaunch <span class="variable">$package</span> <span class="variable">$launch_file</span>&quot;</span> &amp;</span><br><span class="line">            ;;</span><br><span class="line">        2)</span><br><span class="line">            gnome-terminal --tab --title=<span class="string">&quot;<span class="variable">$launch_file</span>&quot;</span> -- bash -c <span class="string">&quot;source <span class="variable">$PROJ_DIR</span>/devel/setup.bash; roslaunch <span class="variable">$package</span> <span class="variable">$launch_file</span>&quot;</span> &amp;</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Invalid START_TYPE: <span class="variable">$START_TYPE</span>&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数：停止所有ROS节点</span></span><br><span class="line"><span class="function"><span class="title">stop_ros_nodes</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Stopping all ROS nodes...&quot;</span></span><br><span class="line">    killall roscore rosmaster rosbag roslaunch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Ctrl-C信号处理函数</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;stop_ros_nodes&#x27;</span> SIGINT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动各个节点</span></span><br><span class="line">start_node <span class="string">&quot;rslidar_sdk&quot;</span> <span class="string">&quot;start.launch&quot;</span></span><br><span class="line">start_node <span class="string">&quot;ros_mscl&quot;</span> <span class="string">&quot;microstrain.launch&quot;</span></span><br><span class="line">start_node <span class="string">&quot;lidar_localization&quot;</span> <span class="string">&quot;run.launch&quot;</span></span><br><span class="line">start_node <span class="string">&quot;call_planning&quot;</span> <span class="string">&quot;localization.launch&quot;</span></span><br><span class="line">start_node <span class="string">&quot;motion_control&quot;</span> <span class="string">&quot;motion_control.launch&quot;</span></span><br><span class="line">start_node <span class="string">&quot;yhs_can_control&quot;</span> <span class="string">&quot;yhs_can_control.launch&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有后台进程结束</span></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure>
<h2 id="生成桌面快捷方式"><a href="#生成桌面快捷方式" class="headerlink" title="生成桌面快捷方式"></a>生成桌面快捷方式</h2><p>创建一个新文件，内容如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=Your_Script_Name</span><br><span class="line">Exec=/path/to/your_script.sh</span><br><span class="line">Terminal=true</span><br><span class="line">Icon=/path/to/your_icon.png</span><br></pre></td></tr></table></figure>
<ul>
<li>Name：快捷方式的名称。</li>
<li>Exec：要执行的脚本文件的完整路径。</li>
<li>Terminal：如果脚本需要在终端中运行，设置为 true；否则设置为 false。</li>
<li>Icon：可选，快捷方式的图标文件的完整路径。</li>
</ul>
<p>将文件保存到桌面或 <code>~/.local/share/applications/</code> 目录下。如果保存到桌面，文件名需要使用 <code>.desktop</code> 后缀，例如 <code>your_script.desktop</code>。如果保存到 <code>~/.local/share/applications/</code> 目录，则无需添加 <code>.desktop</code> 后缀。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/13/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/ros%20bad%20file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/13/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/ros%20bad%20file/" class="post-title-link" itemprop="url">ros bad file</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-13 15:06:04" itemprop="dateCreated datePublished" datetime="2024-03-13T15:06:04+08:00">2024-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" itemprop="url" rel="index"><span itemprop="name">问题解决</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>242</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在WSL的一个ROS工作空间对项目进行编译的时候出现了以下错误信息提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/home/ydx/code/CPP/download_codes/autonomous_yhs_fr07/build/catkin_generated/env_cached.sh: 12: <span class="built_in">export</span>: Files/Microsoft: bad variable name</span><br><span class="line">CMake Error at /opt/ros/melodic/share/catkin/cmake/safe_execute_process.cmake:11 (message):</span><br><span class="line">  </span><br><span class="line">  execute_process(/home/ydx/code/CPP/download_codes/autonomous_yhs_fr07/build/catkin_generated/env_cached.sh</span><br><span class="line">  <span class="string">&quot;/usr/bin/python2&quot;</span> <span class="string">&quot;/usr/bin/empy&quot;</span> <span class="string">&quot;--raw-errors&quot;</span> <span class="string">&quot;-F&quot;</span></span><br><span class="line">  <span class="string">&quot;/home/ydx/code/CPP/download_codes/autonomous_yhs_fr07/build/catkin_generated/order_packages.py&quot;</span></span><br><span class="line">  <span class="string">&quot;-o&quot;</span></span><br><span class="line">  <span class="string">&quot;/home/ydx/code/CPP/download_codes/autonomous_yhs_fr07/build/catkin_generated/order_packages.cmake&quot;</span></span><br><span class="line">  <span class="string">&quot;/opt/ros/melodic/share/catkin/cmake/em/order_packages.cmake.em&quot;</span>) returned</span><br><span class="line">  error code 2</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  /opt/ros/melodic/share/catkin/cmake/em_expand.cmake:25 (safe_execute_process)</span><br><span class="line">  /opt/ros/melodic/share/catkin/cmake/catkin_workspace.cmake:35 (em_expand)</span><br><span class="line">  CMakeLists.txt:69 (catkin_workspace)</span><br></pre></td></tr></table></figure>
<p>由第一行的<code>export: Files/Microsoft: bad variable name</code>可以看出是某个环境变量中有类似<code>Program Files/Microsoft</code>这样的路径导致的错误。显然这和WSL的路径有关。通过在网上查找资料，发现了<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1354999/bad-variable-name-error-on-wsl">askubuntu.com上面的一个帖子</a>有一个类似的问题描述，这里参照第二个回答，先在<code>/etc/wsl.conf</code>文件添加了下面两行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>如果在诸如<code>~/.bashrc</code>或者<code>~/.zshrc</code>文件中添加了类似<code>export PATH=$PATH:/mnt/c/Windows/System32</code>这样的路径，也需要将这些路径注释掉。</p>
<p>然后在<code>PowerShell</code>中执行<code>wsl --shutdown</code>命令彻底关闭WSL后重启WSL，重新编译时不再出现这个错误。在编译完成后，需要将之前完成的更改恢复，否则诸如VSCode等工具将无法正常使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://slam-learner.github.io/2024/03/13/%E6%A8%A1%E6%9D%BF/bash%E8%84%9A%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.gif">
      <meta itemprop="name" content="ydx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ydxの博客">
      <meta itemprop="description" content="江苏大学 | 车辆工程 | SLAM">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ydxの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/13/%E6%A8%A1%E6%9D%BF/bash%E8%84%9A%E6%9C%AC/" class="post-title-link" itemprop="url">bash脚本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-13 13:52:04" itemprop="dateCreated datePublished" datetime="2024-03-13T13:52:04+08:00">2024-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-09 22:01:43" itemprop="dateModified" datetime="2025-06-09T22:01:43+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index"><span itemprop="name">模板</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在项目本地编译安装第三方库而不是安装到系统目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## author: ydx</span></span><br><span class="line"><span class="comment">## description: 在项目本地编译安装第三方库而不是安装到系统目录</span></span><br><span class="line"><span class="comment">## date: 2023-12-25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录脚本、项目目录</span></span><br><span class="line">SCRIPT_DIR=<span class="string">&quot;<span class="subst">$( cd <span class="string">&quot;<span class="subst">$( dirname <span class="string">&quot;<span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span> )</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; pwd )</span>&quot;</span></span><br><span class="line">PROJECT_DIR=<span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>/..&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有指定编译类型，则默认为Release</span></span><br><span class="line">BUILD_TYPE=<span class="string">&quot;<span class="variable">$&#123;1:-Release&#125;</span>&quot;</span></span><br><span class="line">CLEAN_BUILD=<span class="string">&quot;<span class="variable">$&#123;2:-false&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Build type of third party: <span class="variable">$BUILD_TYPE</span>&quot;</span></span><br><span class="line"></span><br><span class="line">SPLIT_LINE=<span class="string">&quot;####################################################################&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set -x # 打开调试模式，每行命令执行前都会打印该命令</span></span><br><span class="line"><span class="built_in">set</span> -e <span class="comment"># 出错则退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查gcc和g++是否安装, 如果没有安装则安装gcc和g++</span></span><br><span class="line"><span class="built_in">which</span> gcc &gt; /dev/null 2&gt;&amp;1 || &#123; <span class="built_in">echo</span> <span class="string">&quot;gcc not found! Trying to install gcc!&quot;</span>; sudo apt-get install gcc; &#125;</span><br><span class="line"><span class="built_in">which</span> g++ &gt; /dev/null 2&gt;&amp;1 || &#123; <span class="built_in">echo</span> <span class="string">&quot;g++ not found! Trying to install g++!&quot;</span>; sudo apt-get install g++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于C++17的良好支持，需要g++9以上版本，这里进行检查</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$CXX</span>&quot;</span>]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> VER <span class="keyword">in</span> 9 10 11 12 13; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hash</span> g++-<span class="variable">$VER</span> 2&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">export</span> CXX=g++-<span class="variable">$VER</span></span><br><span class="line">            <span class="built_in">export</span> CC=gcc-<span class="variable">$VER</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有找到g++9以上版本，则尝试更新gcc和g++到gcc-9 g++-9</span></span><br><span class="line"><span class="comment"># if [ -z STRING ] 测试STRING是否为空，如果为空返回 true</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$CXX</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;No g++ version 9 or higher found! Trying to update gcc and g++ to gcc-9 g++-9 for C++17 support!&quot;</span></span><br><span class="line">    sudo sh <span class="variable">$SCRIPT_DIR</span>/update-gcc-g++.sh</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hash</span> g++-9 2&gt; dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> CXX=g++-9</span><br><span class="line">        <span class="built_in">export</span> CC=gcc-9</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查gcc和g++编译器是否存在</span></span><br><span class="line"><span class="comment"># if [ -n STRING ] 测试STRING是否为空，如果非空返回 true</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CXX</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">which</span> <span class="string">&quot;<span class="variable">$CXX</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;No g++ version 9 or higher found! Please install g++-9 or higher!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CC</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">which</span> <span class="string">&quot;<span class="variable">$CC</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;No gcc version 9 or higher found! Please install gcc-9 or higher!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用同样的标准对各个库进行编译</span></span><br><span class="line">YHS_CXX_STANDARD=14</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;C++ standard: <span class="variable">$YHS_CXX_STANDARD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取逻辑CPU核心数，用于并行编译，如果获取失败则默认为1</span></span><br><span class="line">NUM_CORES=`(<span class="built_in">which</span> <span class="built_in">nproc</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">nproc</span>) || sysctl -n hw.logicalcpu || <span class="built_in">echo</span> 1`</span><br><span class="line">NUM_PARALLEL_BUILDS=<span class="variable">$NUM_CORES</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Number of build thread: <span class="variable">$NUM_CORES</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Eigen默认使用16字节的对齐，但当AVX指令集可用时，Eigen会使用32字节的对齐</span></span><br><span class="line"><span class="comment"># 如果各个库或者项目使用了不同的对齐方式，可能会导致内存访问错误</span></span><br><span class="line"><span class="comment"># 而 Ceres 库以及 OpenGV 库在release模式会强制性传递 arch=native 选项</span></span><br><span class="line"><span class="comment"># 在现代的CPU上，arch=native 选项会启用 SSE4.2 和 AVX 指令集也就是会使用32字节的对齐</span></span><br><span class="line"><span class="comment"># 为了防止Eigen库引入一些微妙的bug，需要在各处编译时都加入arc=native选项</span></span><br><span class="line"><span class="comment"># 参见：https://eigen.tuxfamily.org/dox/TopicPreprocessorDirectives.html</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    CMAKE_MARCH=<span class="string">&quot;&#123;CXX_MARCH:-native&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$CXX_MARCH</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    EXTRA_CXX_FLAGS=<span class="string">&quot;<span class="variable">$EXTRA_CXX_FLAGS</span> -march=<span class="variable">$CXX_MARCH</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">EXTRA_CXX_FLAGS=<span class="string">&quot;<span class="variable">$&#123;EXTRA_CXX_FLAGS&#125;</span> <span class="variable">$&#123;CXX_FLAGS&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">INSTALL_DIR=<span class="string">&quot;<span class="variable">$PROJECT_DIR</span>/install&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用的CMake参数</span></span><br><span class="line"><span class="comment"># -DCMAKE_BUILD_TYPE=$&#123;BUILD_TYPE&#125; 指定编译类型</span></span><br><span class="line"><span class="comment"># -DCMAKE_CXX_STANDARD=$&#123;YHS_CXX_STANDARD&#125; 指定C++标准</span></span><br><span class="line"><span class="comment"># -DCMAKE_CXX_FLAGS=&quot;$&#123;EXTRA_CXX_FLAGS&#125;&quot; 指定额外的C++编译选项</span></span><br><span class="line"><span class="comment"># -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_DIR&#125; 指定安装目录</span></span><br><span class="line"><span class="comment"># -DCMAKE_PREFIX_PATH=$&#123;INSTALL_DIR&#125; 指定查找依赖库的路径, find_package()会在这个路径下查找依赖库</span></span><br><span class="line"><span class="comment"># -DCMAKE_CXX_EXTENSIONS=OFF 禁用C++扩展</span></span><br><span class="line"><span class="comment"># -DCMAKE_POSITION_INDEPENDENT_CODE=ON 生成位置无关的代码</span></span><br><span class="line"><span class="comment"># -DBUILD_SHARED_LIBS=OFF 禁用动态库</span></span><br><span class="line">COMMON_CMAKE_ARGS=(</span><br><span class="line">    -DCMAKE_BUILD_TYPE=<span class="variable">$&#123;BUILD_TYPE&#125;</span></span><br><span class="line">    -DCMAKE_CXX_STANDARD=<span class="variable">$&#123;YHS_CXX_STANDARD&#125;</span></span><br><span class="line">    -DCMAKE_CXX_FLAGS=<span class="string">&quot;<span class="variable">$&#123;EXTRA_CXX_FLAGS&#125;</span>&quot;</span></span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;INSTALL_DIR&#125;</span></span><br><span class="line">    -DCMAKE_PREFIX_PATH=<span class="variable">$&#123;INSTALL_DIR&#125;</span></span><br><span class="line">    -DCMAKE_CXX_EXTENSIONS=OFF</span><br><span class="line">    -DCMAKE_POSITION_INDEPENDENT_CODE=ON</span><br><span class="line">    -DBUILD_SHARED_LIBS=OFF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查ccache是否可用，如果可用则使用ccache加速编译</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v ccache &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ccache found! Using ccache to speed up compilation!&quot;</span></span><br><span class="line">    COMMON_CMAKE_ARGS+=(</span><br><span class="line">            -DCMAKE_C_COMPILER_LAUNCHER=ccache</span><br><span class="line">            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;COMMON_CMAKE_ARGS[@]&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ccache not found! Compiling without ccache!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$INSTALL_DIR</span>&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$INSTALL_DIR</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于有的库之间存在依赖关系，并且有的库需要额外添加一些编译选项，所以需要按照顺序手工编译</span></span><br><span class="line">THIRD_DIR=<span class="string">&quot;<span class="variable">$PROJECT_DIR</span>/third_party&quot;</span></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="comment">## Eigen</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Building Eigen...&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$THIRD_DIR</span>/eigen-3.4.0&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CLEAN_BUILD</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -rf build</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p build</span><br><span class="line">    <span class="built_in">cd</span> build</span><br><span class="line">    cmake .. <span class="string">&quot;<span class="variable">$&#123;COMMON_CMAKE_ARGS[@]&#125;</span>&quot;</span> \</span><br><span class="line">        -DBUILD_TESTING=OFF</span><br><span class="line">    make -j<span class="variable">$NUM_PARALLEL_BUILDS</span></span><br><span class="line">    make install</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="comment">## yaml-cpp</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Building yaml-cpp...&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$THIRD_DIR</span>/yaml-cpp&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CLEAN_BUILD</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -rf build</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p build</span><br><span class="line">    <span class="built_in">cd</span> build</span><br><span class="line">    cmake .. <span class="string">&quot;<span class="variable">$&#123;COMMON_CMAKE_ARGS[@]&#125;</span>&quot;</span></span><br><span class="line">    make -j<span class="variable">$NUM_PARALLEL_BUILDS</span></span><br><span class="line">    make install</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="comment">## OpenCV 4.5.4</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Building OpenCV...&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$THIRD_DIR</span>/opencv-4.5.4&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CLEAN_BUILD</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -rf build</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p build</span><br><span class="line">    <span class="built_in">cd</span> build</span><br><span class="line">    cmake .. <span class="string">&quot;<span class="variable">$&#123;COMMON_CMAKE_ARGS[@]&#125;</span>&quot;</span> \</span><br><span class="line">        -DCMAKE_VERBOSE_MAKEFILE=ON \</span><br><span class="line">        -DOPENCV_ENABLE_NONFREE=ON \</span><br><span class="line">        -DOPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">        -DWITH_IPP=ON -DWITH_TBB=ON -DWITH_OPENMP=ON -DWITH_PTHREADS_PF=ON \</span><br><span class="line">        -DWITH_1394=OFF \</span><br><span class="line">        -DBUILD_TESTS=OFF \</span><br><span class="line">        -DBUILD_PERF_TESTS=OFF \</span><br><span class="line">        -DENABLE_CXX11=ON \</span><br><span class="line">        -DBUILD_DOCS=OFF \</span><br><span class="line">        -DBUILD_EXAMPLES=OFF \</span><br><span class="line">        -DBUILD_JASPER=OFF \</span><br><span class="line">        -DBUILD_OPENEXR=OFF \</span><br><span class="line">        -DWITH_FFMPEG=ON \</span><br><span class="line">        -DWITH_EIGEN=ON \</span><br><span class="line">        -DWITH_LAPACK=OFF</span><br><span class="line">    make -j12</span><br><span class="line">    make install</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"><span class="comment">## gtsam</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Building gtsam...&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$THIRD_DIR</span>/gtsam-4.0.3&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CLEAN_BUILD</span>&quot;</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -rf build</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p build</span><br><span class="line">    <span class="built_in">cd</span> build</span><br><span class="line">    cmake .. <span class="string">&quot;<span class="variable">$&#123;COMMON_CMAKE_ARGS[@]&#125;</span>&quot;</span></span><br><span class="line">    make -j<span class="variable">$NUM_PARALLEL_BUILDS</span></span><br><span class="line">    make install</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SPLIT_LINE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All third party libraries are built and installed to <span class="variable">$INSTALL_DIR</span>!&quot;</span></span><br></pre></td></tr></table></figure>
<p>更新gcc和g++到gcc-9 g++-9</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## author: ydx</span></span><br><span class="line"><span class="comment">## description: update gcc and g++ to gcc-9 g++-9 for C++17 support</span></span><br><span class="line"><span class="comment">## date: 2023-12-25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Trying to update gcc and g++ to gcc-9 g++-9 for C++17 support!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You may need to enter your password!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;add-apt-repository ppa:ubuntu-toolchain-r/test&quot;</span></span><br><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;update apt-get&quot;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;install gcc-9 g++-9, wait a moment!&quot;</span></span><br><span class="line">sudo apt-get install gcc-9 g++-9</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;set gcc-9 g++-9 as default gcc g++&quot;</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 20 --slave /usr/bin/g++ g++ /usr/bin/g++-9</span><br></pre></td></tr></table></figure>
<p>更新cmake到3.22.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## author: ydx</span></span><br><span class="line"><span class="comment">## description: 升级cmake到3.22.1</span></span><br><span class="line"><span class="comment">## date: 2023-12-25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_VERSION=`cmake --version | grep version | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Trying to update cmake&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/package</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Downloading cmake-3.22.1.tar.gz&quot;</span></span><br><span class="line">wget https://cmake.org/files/v3.22/cmake-3.22.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Unpacking cmake-3.22.1.tar.gz&quot;</span></span><br><span class="line">tar -zxvf cmake-3.22.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Installing cmake-3.22.1&quot;</span></span><br><span class="line"><span class="built_in">cd</span> cmake-3.22.1</span><br><span class="line"><span class="built_in">chmod</span> a+x ./configure</span><br><span class="line">sh ./configure</span><br><span class="line"></span><br><span class="line">NUM_CORES=`(<span class="built_in">which</span> <span class="built_in">nproc</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">nproc</span>) || sysctl -n hw.logicalcpu || <span class="built_in">echo</span> 1`</span><br><span class="line">make -j<span class="variable">$NUM_CORES</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Trying to install cmake-3.22.1 to system directory, you may need to enter your password!&quot;</span></span><br><span class="line">sudo make install</span><br><span class="line">sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 --force</span><br><span class="line"></span><br><span class="line">CMAKE_NEW_VERSION=`cmake --version | grep version | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$CMAKE_NEW_VERSION</span>&quot;</span> = <span class="string">&quot;<span class="variable">$CMAKE_CURRENT_VERSION</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Failed to update cmake!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Successfully update cmake from <span class="variable">$CMAKE_CURRENT_VERSION</span> to <span class="variable">$CMAKE_NEW_VERSION</span>!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ydx</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">42k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:32</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/slam-learner" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"slam-learner","repo":"RepoForBlogComment","client_id":"f732afefb5f22b42282a","client_secret":"c8993c751222209026810c1812c7e5f127464761","admin_user":"slam-learner","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":["zh-CN"],"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
